<p><a href="http://travis-ci.org/survivejs/webpack-merge"><img src="https://secure.travis-ci.org/survivejs/webpack-merge.svg" alt="build status" /></a> <a href="https://www.bithound.io/github/survivejs/webpack-merge"><img src="https://www.bithound.io/github/survivejs/webpack-merge/badges/score.svg" alt="bitHound Score" /></a> <a href="https://codecov.io/gh/survivejs/webpack-merge"><img src="https://codecov.io/gh/survivejs/webpack-merge/branch/master/graph/badge.svg" alt="codecov" /></a></p>

<h1>webpack-merge - Merge designed for Webpack</h1>

<p><strong>webpack-merge</strong> provides a <code>merge</code> function that concatenates arrays and merges objects creating a new object. If functions are encountered, it will execute them, run the results through the algorithm, and then wrap the returned values within a function again.</p>

<p>This behavior is particularly useful in configuring webpack although it has uses beyond it. Whenever you need to merge configuration objects, <strong>webpack-merge</strong> can come in handy.</p>

<p>There’s also a webpack specific merge variant known as <code>merge.smart</code> that’s able to take webpack specifics into account (i.e., it can flatten loader definitions).</p>

<h2>Standard Merging</h2>

<h3><strong><code>merge(...configuration | [...configuration])</code></strong></h3>

<p><code>merge</code> is the core, and the most important idea, of the API. Often this is all you need unless you want further customization.</p>

<p>```javascript
// Default API
var output = merge(object1, object2, object3, …);</p>

<p>// You can pass an array of objects directly.
// This works with all available functions.
var output = merge([object1, object2, object3]);
```</p>

<h3><strong><code>merge({ customizeArray, customizeObject })(...configuration | [...configuration])</code></strong></h3>

<p><code>merge</code> behavior can be customized per field through a curried customization API.</p>

<p>```javascript
// Customizing array/object behavior
var output = merge(
  {
    customizeArray(a, b, key) {
      if (key === ‘extensions’) {
        return _.uniq([…a, …b]);
      }</p>

<pre><code>  // Fall back to default merging
  return undefined;
},
customizeObject(a, b, key) {
  if (key === 'module') {
    // Custom merging
    return _.merge({}, a, b);
  }

  // Fall back to default merging
  return undefined;
}   } )(object1, object2, object3, ...); ``` For example, if the previous code was invoked with only `object1` and `object2` with `object1` as: ``` {
foo1: ['object1'],
foo2: ['object1'],
bar1: { object1: {} },
bar2: { object1: {} }, } ``` and `object2` as: ``` {
foo1: ['object2'],
foo2: ['object2'],
bar1: { object2: {} },
bar2: { object2: {} }, } ``` then `customizeArray` will be invoked for each property of `Array` type, i.e: ``` customizeArray(['object1'], ['object2'], 'foo1'); customizeArray(['object1'], ['object2'], 'foo2'); ``` and `customizeObject` will be invoked for each property of `Object` type, i.e: ``` customizeObject({ object1: {} }, { object2: {} }, bar1); customizeObject({ object1: {} }, { object2: {} }, bar2); ```
</code></pre>

<h3><strong><code>merge.unique(<field>, <fields>, field => field)</code></strong></h3>

<p>```javascript
const output = merge({
  customizeArray: merge.unique(
    ‘plugins’,
    [‘HotModuleReplacementPlugin’],
    plugin => plugin.constructor && plugin.constructor.name
  )
})({
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
}, {
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
});</p>

<p>// Output contains only single HotModuleReplacementPlugin now.
```</p>

<h2>Merging with Strategies</h2>

<h3><strong><code>merge.strategy({ <field>: '<prepend|append|replace>''})(...configuration | [...configuration])</code></strong></h3>

<p>Given you may want to configure merging behavior per field, there’s a strategy variant:</p>

<p><code>javascript
// Merging with a specific merge strategy
var output = merge.strategy(
  {
    entry: 'prepend', // or 'replace', defaults to 'append'
    'module.loaders': 'prepend'
  }
)(object1, object2, object3, ...);
</code></p>

<h3><strong><code>merge.smartStrategy({ <key>: '<prepend|append|replace>''})(...configuration | [...configuration])</code></strong></h3>

<p>The same idea works with smart merging too (described below in greater detail).</p>

<p><code>javascript
var output = merge.smartStrategy(
  {
    entry: 'prepend', // or 'replace'
    'module.loaders': 'prepend'
  }
)(object1, object2, object3, ...);
</code></p>

<h2>Smart Merging</h2>

<h3><strong><code>merge.smart(...configuration | [...configuration])</code></strong></h3>

<p><em>webpack-merge</em> tries to be smart about merging loaders when <code>merge.smart</code> is used. Loaders with matching tests will be merged into a single loader value.</p>

<p>Note that the logic picks up webpack 2 <code>rules</code> kind of syntax as well. The examples below have been written in webpack 1 syntax.</p>

<p><strong>package.json</strong></p>

<p><code>json5
{
  "scripts": {
    "start": "webpack-dev-server",
    "build": "webpack"
  },
  // ...
}
</code></p>

<p><strong>webpack.config.js</strong></p>

<p>```javascript
var path = require(‘path’);
var merge = require(‘webpack-merge’);</p>

<p>var TARGET = process.env.npm_lifecycle_event;</p>

<p>var common = {
  entry: path.join(__dirname, ‘app’),
  …
  module: {
    loaders: [
      {
        test: /.css$/,
        loaders: [‘style’, ‘css’],
      },
    ],
  },
};</p>

<p>if(TARGET === ‘start’) {
  module.exports = merge(common, {
    module: {
      // loaders will get concatenated!
      loaders: [
        {
          test: /.jsx?$/,
          loader: ‘babel?stage=1’,
          include: path.join(ROOT_PATH, ‘app’),
        },
      ],
    },
    …
  });
}</p>

<p>if(TARGET === ‘build’) {
  module.exports = merge(common, {
    …
  });
}</p>

<p>…
```</p>

<p><strong>Loader string values <code>loader: 'babel'</code> override each other.</strong></p>

<p><code>javascript
merge.smart({
  loaders: [{
    test: /\.js$/,
    loader: 'babel'
  }]
}, {
  loaders: [{
    test: /\.js$/,
    loader: 'coffee'
  }]
});
// will become
{
  loaders: [{
    test: /\.js$/,
    loader: 'coffee'
  }]
}
</code></p>

<p><strong>Loader array values <code>loaders: ['babel']</code> will be merged, without duplication.</strong></p>

<p><code>javascript
merge.smart({
  loaders: [{
    test: /\.js$/,
    loaders: ['babel']
  }]
}, {
  loaders: [{
    test: /\.js$/,
    loaders: ['coffee']
  }]
});
// will become
{
  loaders: [{
    test: /\.js$/,
    // appended because Webpack evaluated these from right to left
    // this way you can specialize behavior and build the loader chain
    loaders: ['babel', 'coffee']
  }]
}
</code></p>

<p><strong>Loader array values <code>loaders: ['babel']</code> can be reordered by including
original loaders.</strong></p>

<p><code>javascript
merge.smart({
  loaders: [{
    test: /\.js$/,
    loaders: ['babel']
  }]
}, {
  loaders: [{
    test: /\.js$/,
    loaders: ['react-hot', 'babel']
  }]
});
// will become
{
  loaders: [{
    test: /\.js$/,
    // order of second argument is respected
    loaders: ['react-hot', 'babel']
  }]
}
</code></p>

<p><strong>Loader query strings <code>loaders: ['babel?plugins[]=object-assign']</code> will be overridden.</strong></p>

<p><code>javascript
merge.smart({
  loaders: [{
    test: /\.js$/,
    loaders: ['babel?plugins[]=object-assign']
  }]
}, {
  loaders: [{
    test: /\.js$/,
    loaders: ['babel', 'coffee']
  }]
});
// will become
{
  loaders: [{
    test: /\.js$/,
    loaders: ['babel', 'coffee']
  }]
}
</code></p>

<p><strong>Loader arrays in source values will have loader strings merged into them.</strong></p>

<p><code>javascript
merge.smart({
  loaders: [{
    test: /\.js$/,
    loader: 'babel'
  }]
}, {
  loaders: [{
    test: /\.js$/,
    loaders: ['coffee']
  }]
});
// will become
{
  loaders: [{
    test: /\.js$/,
    // appended because Webpack evaluated these from right to left!
    loaders: ['babel', 'coffee']
  }]
}
</code></p>

<p><strong>Loader strings in source values will always override.</strong></p>

<p><code>javascript
merge.smart({
  loaders: [{
    test: /\.js$/,
    loaders: ['babel']
  }]
}, {
  loaders: [{
    test: /\.js$/,
    loader: 'coffee'
  }]
});
// will become
{
  loaders: [{
    test: /\.js$/,
    loader: 'coffee'
  }]
}
</code></p>

<h2>Multiple Merging</h2>

<h3><strong><code>merge.multiple(...configuration | [...configuration])</code></strong></h3>

<p>Sometimes you may need to support multiple targets, <em>webpack-merge</em> will accept an object where each key represents the target configuration. The output becomes an <em>array</em> of configurations where matching keys are merged and non-matching keys are added.</p>

<p>```javascript
var path = require(‘path’);
var baseConfig = {
    server: {
      target: ‘node’,
      output: {
        path: path.resolve(__dirname, ‘dist’),
        filename: ‘lib.node.js’
      }
    },
    client: {
      output: {
        path: path.resolve(__dirname, ‘dist’),
        filename: ‘lib.js’
      }
    }
  };</p>

<p>// specialized configuration
var production = {
    client: {
      output: {
        path: path.resolve(__dirname, ‘dist’),
        filename: ‘[name].[hash].js’
      }
    }
  }</p>

<p>module.exports = merge.multiple(baseConfig, production)
```</p>

<blockquote>
  <p>Check out <a href="http://survivejs.com/">SurviveJS - Webpack and React</a> to dig deeper into the topic.</p>
</blockquote>

<h2>Development</h2>

<ol>
  <li><code>npm i</code></li>
  <li><code>npm run watch</code></li>
</ol>

<p>Before contributing, please open an issue where to discuss.</p>

<h2>License</h2>

<p><em>webpack-merge</em> is available under MIT. See LICENSE for more details.</p>