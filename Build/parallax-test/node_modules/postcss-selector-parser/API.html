<h1>API Documentation</h1>

<p><em>Please use only this documented API when working with the parser. Methods
not documented here are subject to change at any point.</em></p>

<h2><code>parser</code> function</h2>

<p>This is the module’s main entry point.</p>

<p><code>js
var parser = require('postcss-selector-parser');
</code></p>

<h3><code>parser([transform])</code></h3>

<p>Creates a new <code>processor</code> instance</p>

<p>```js
var processor = parser();</p>

<p>// or, with optional transform function
var transform = function (selectors) {
    selectors.eachUniversal(function (selector) {
        selector.remove();
    });
};</p>

<p>var processor = parser(transform)</p>

<p>// Example
var result = processor.process(‘*.class’).result;
// => .class
```</p>

<p><a href="#processor">See processor documentation</a></p>

<p>Arguments:</p>

<ul>
  <li><code>transform (function)</code>: Provide a function to work with the parsed AST.</li>
</ul>

<h3><code>parser.attribute([props])</code></h3>

<p>Creates a new attribute selector.</p>

<p><code>js
parser.attribute({attribute: 'href'});
// => [href]
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.className([props])</code></h3>

<p>Creates a new class selector.</p>

<p><code>js
parser.className({value: 'button'});
// => .button
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.combinator([props])</code></h3>

<p>Creates a new selector combinator.</p>

<p><code>js
parser.combinator({value: '+'});
// => +
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.comment([props])</code></h3>

<p>Creates a new comment.</p>

<p><code>js
parser.comment({value: '/* Affirmative, Dave. I read you. */'});
// => /* Affirmative, Dave. I read you. */
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.id([props])</code></h3>

<p>Creates a new id selector.</p>

<p><code>js
parser.id({value: 'search'});
// => #search
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.nesting([props])</code></h3>

<p>Creates a new nesting selector.</p>

<p><code>js
parser.nesting();
// => &
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.pseudo([props])</code></h3>

<p>Creates a new pseudo selector.</p>

<p><code>js
parser.pseudo({value: '::before'});
// => ::before
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.root([props])</code></h3>

<p>Creates a new root node.</p>

<p><code>js
parser.root();
// => (empty)
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.selector([props])</code></h3>

<p>Creates a new selector node.</p>

<p><code>js
parser.selector();
// => (empty)
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.string([props])</code></h3>

<p>Creates a new string node.</p>

<p><code>js
parser.string();
// => (empty)
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.tag([props])</code></h3>

<p>Creates a new tag selector.</p>

<p><code>js
parser.tag({value: 'button'});
// => button
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h3><code>parser.universal([props])</code></h3>

<p>Creates a new universal selector.</p>

<p><code>js
parser.universal();
// => *
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>props (object)</code>: The new node’s properties.</li>
</ul>

<h2>Node types</h2>

<h3><code>node.type</code></h3>

<p>A string representation of the selector type. It can be one of the following;
<code>attribute</code>, <code>class</code>, <code>combinator</code>, <code>comment</code>, <code>id</code>, <code>nesting</code>, <code>pseudo</code>,
<code>root</code>, <code>selector</code>, <code>string</code>, <code>tag</code>, or <code>universal</code>. Note that for convenience,
these constants are exposed on the main <code>parser</code> as uppercased keys. So for
example you can get <code>id</code> by querying <code>parser.ID</code>.</p>

<p><code>js
parser.attribute({attribute: 'href'}).type;
// => 'attribute'
</code></p>

<h3><code>node.parent</code></h3>

<p>Returns the parent node.</p>

<p><code>js
root.nodes[0].parent === root;
</code></p>

<h3><code>node.toString()</code>, <code>String(node)</code>, or <code>'' + node</code></h3>

<p>Returns a string representation of the node.</p>

<p><code>js
var id = parser.id({value: 'search'});
console.log(String(id));
// => #search
</code></p>

<h3><code>node.next()</code> & <code>node.prev()</code></h3>

<p>Returns the next/previous child of the parent node.</p>

<p><code>js
var next = id.next();
if (next && next.type !== 'combinator') {
    throw new Error('Qualified IDs are not allowed!');
}
</code></p>

<h3><code>node.replaceWith(node)</code></h3>

<p>Replace a node with another.</p>

<p><code>js
var attr = selectors.first.first;
var className = parser.className({value: 'test'});
attr.replaceWith(className);
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>node</code>: The node to substitute the original with.</li>
</ul>

<h3><code>node.remove()</code></h3>

<p>Removes the node from its parent node.</p>

<p><code>js
if (node.type === 'id') {
    node.remove();
}
</code></p>

<h3><code>node.clone()</code></h3>

<p>Returns a copy of a node, detached from any parent containers that the
original might have had.</p>

<p>```js
var cloned = parser.id({value: ‘search’});
String(cloned);</p>

<p>// => #search
```</p>

<h3><code>node.spaces</code></h3>

<p>Extra whitespaces around the node will be moved into <code>node.spaces.before</code> and
<code>node.spaces.after</code>. So for example, these spaces will be moved as they have
no semantic meaning:</p>

<p><code>css
      h1     ,     h2   {}
</code></p>

<p>However, <em>combinating</em> spaces will form a <code>combinator</code> node:</p>

<p><code>css
h1        h2 {}
</code></p>

<p>A <code>combinator</code> node may only have the <code>spaces</code> property set if the combinator
value is a non-whitespace character, such as <code>+</code>, <code>~</code> or <code>></code>. Otherwise, the
combinator value will contain all of the spaces between selectors.</p>

<h3><code>node.source</code></h3>

<p>An object describing the node’s start/end, line/column source position.</p>

<p>Within the following CSS, the <code>.bar</code> class node …</p>

<p><code>css
.foo,
  .bar {}
</code></p>

<p>… will contain the following <code>source</code> object.</p>

<p><code>js
source: {
    start: {
        line: 2,
        column: 3
    },
    end: {
        line: 2,
        column: 6
    }
}
</code></p>

<h3><code>node.sourceIndex</code></h3>

<p>The zero-based index of the node within the original source string.</p>

<p>Within the following CSS, the <code>.baz</code> class node will have a <code>sourceIndex</code> of <code>12</code>.</p>

<p><code>css
.foo, .bar, .baz {}
</code></p>

<h2>Container types</h2>

<p>The <code>root</code>, <code>selector</code>, and <code>pseudo</code> nodes have some helper methods for working
with their children.</p>

<h3><code>container.nodes</code></h3>

<p>An array of the container’s children.</p>

<p><code>js
// Input: h1 h2
selectors.at(0).nodes.length   // => 3
selectors.at(0).nodes[0].value // => 'h1'
selectors.at(0).nodes[1].value // => ' '
</code></p>

<h3><code>container.first</code> & <code>container.last</code></h3>

<p>The first/last child of the container.</p>

<p><code>js
selector.first === selector.nodes[0];
selector.last === selector.nodes[selector.nodes.length - 1];
</code></p>

<h3><code>container.at(index)</code></h3>

<p>Returns the node at position <code>index</code>.</p>

<p><code>js
selector.at(0) === selector.first;
selector.at(0) === selector.nodes[0];
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>index</code>: The index of the node to return.</li>
</ul>

<h3><code>container.index(node)</code></h3>

<p>Return the index of the node within its container.</p>

<p><code>js
selector.index(selector.nodes[2]) // => 2
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>node</code>: A node within the current container.</li>
</ul>

<h3><code>container.length</code></h3>

<p>Proxy to the length of the container’s nodes.</p>

<p><code>js
container.length === container.nodes.length
</code></p>

<h3><code>container</code> Array iterators</h3>

<p>The container class provides proxies to certain Array methods; these are:</p>

<ul>
  <li><code>container.map === container.nodes.map</code></li>
  <li><code>container.reduce === container.nodes.reduce</code></li>
  <li><code>container.every === container.nodes.every</code></li>
  <li><code>container.some === container.nodes.some</code></li>
  <li><code>container.filter === container.nodes.filter</code></li>
  <li><code>container.sort === container.nodes.sort</code></li>
</ul>

<p>Note that these methods only work on a container’s immediate children; recursive
iteration is provided by <code>container.walk</code>.</p>

<h3><code>container.each(callback)</code></h3>

<p>Iterate the container’s immediate children, calling <code>callback</code> for each child.
You may return <code>false</code> within the callback to break the iteration.</p>

<p><code>js
var className;
selectors.each(function (selector, index) {
    if (selector.type === 'class') {
        className = selector.value;
        return false;
    }
});
</code></p>

<p>Note that unlike <code>Array#forEach()</code>, this iterator is safe to use whilst adding
or removing nodes from the container.</p>

<p>Arguments:</p>

<ul>
  <li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>

<h3><code>container.walk(callback)</code></h3>

<p>Like <code>container#each</code>, but will also iterate child nodes as long as they are
<code>container</code> types.</p>

<p><code>js
selectors.walk(function (selector, index) {
    // all nodes
});
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>

<p>This iterator is safe to use whilst mutating <code>container.nodes</code>,
like <code>container#each</code>.</p>

<h3><code>container.walk</code> proxies</h3>

<p>The container class provides proxy methods for iterating over types of nodes,
so that it is easier to write modules that target specific selectors. Those
methods are:</p>

<ul>
  <li><code>container.walkAttributes</code></li>
  <li><code>container.walkClasses</code></li>
  <li><code>container.walkCombinators</code></li>
  <li><code>container.walkComments</code></li>
  <li><code>container.walkIds</code></li>
  <li><code>container.walkNesting</code></li>
  <li><code>container.walkPseudos</code></li>
  <li><code>container.walkTags</code></li>
  <li><code>container.walkUniversals</code></li>
</ul>

<h3><code>container.split(callback)</code></h3>

<p>This method allows you to split a group of nodes by returning <code>true</code> from
a callback. It returns an array of arrays, where each inner array corresponds
to the groups that you created via the callback.</p>

<p>```js
// (input) => h1 h2»h3
var list = selectors.first.split((selector) => {
    return selector.type === ‘combinator’;
});</p>

<p>// (node values) => [[‘h1’, ‘ ‘], [‘h2’, ‘»’], [‘h3’]]
```</p>

<p>Arguments:</p>

<ul>
  <li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
as an argument.</li>
</ul>

<h3><code>container.prepend(node)</code> & <code>container.append(node)</code></h3>

<p>Add a node to the start/end of the container. Note that doing so will set
the parent property of the node to this container.</p>

<p><code>js
var id = parser.id({value: 'search'});
selector.append(id);
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>node</code>: The node to add.</li>
</ul>

<h3><code>container.insertBefore(old, new)</code> & <code>container.insertAfter(old, new)</code></h3>

<p>Add a node before or after an existing node in a container:</p>

<p><code>js
selectors.walk(function (selector) {
    if (selector.type !== 'class') {
        var className = parser.className({value: 'theme-name'});
        selector.parent.insertAfter(selector, className);
    }
});
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>old</code>: The existing node in the container.</li>
  <li><code>new</code>: The new node to add before/after the existing node.</li>
</ul>

<h3><code>container.removeChild(node)</code></h3>

<p>Remove the node from the container. Note that you can also use
<code>node.remove()</code> if you would like to remove just a single node.</p>

<p><code>js
selector.length // => 2
selector.remove(id)
selector.length // => 1;
id.parent       // undefined
</code></p>

<p>Arguments:</p>

<ul>
  <li><code>node</code>: The node to remove.</li>
</ul>

<h3><code>container.removeAll()</code> or <code>container.empty()</code></h3>

<p>Remove all children from the container.</p>

<p><code>js
selector.removeAll();
selector.length // => 0
</code></p>

<h2>Root nodes</h2>

<p>A root node represents a comma separated list of selectors. Indeed, all
a root’s <code>toString()</code> method does is join its selector children with a ‘,’.
Other than this, it has no special functionality and acts like a container.</p>

<h3><code>root.trailingComma</code></h3>

<p>This will be set to <code>true</code> if the input has a trailing comma, in order to
support parsing of legacy CSS hacks.</p>

<h2>Selector nodes</h2>

<p>A selector node represents a single compound selector. For example, this
selector string <code>h1 h2 h3, [href] > p</code>, is represented as two selector nodes.
It has no special functionality of its own.</p>

<h2>Pseudo nodes</h2>

<p>A pseudo selector extends a container node; if it has any parameters of its
own (such as <code>h1:not(h2, h3)</code>), they will be its children. Note that the pseudo
<code>value</code> will always contain the colons preceding the pseudo identifier. This
is so that both <code>:before</code> and <code>::before</code> are properly represented in the AST.</p>

<h2>Attribute nodes</h2>

<h3><code>attribute.quoted</code></h3>

<p>Returns <code>true</code> if the attribute’s value is wrapped in quotation marks, false if it is not.
Remains <code>undefined</code> if there is no attribute value.</p>

<p><code>css
[href=foo] /* false */
[href='foo'] /* true */
[href="foo"] /* true */
[href] /* undefined */
</code></p>

<h3><code>attribute.raws.unquoted</code></h3>

<p>Returns the unquoted content of the attribute’s value.
Remains <code>undefined</code> if there is no attribute value.</p>

<p><code>css
[href=foo] /* foo */
[href='foo'] /* foo */
[href="foo"] /* foo */
[href] /* undefined */
</code></p>

<h3><code>attribute.raws.insensitive</code></h3>

<p>If there is an <code>i</code> specifying case insensitivity, returns that <code>i</code> along with the whitespace
around it.</p>

<p><code>css
[id=Bar i ] /* " i " */
[id=Bar   i  ] /* "   i  " */
</code></p>

<h2><code>processor</code></h2>

<h3><code>process(cssText, [options])</code></h3>

<p>Processes the <code>cssText</code>, returning the parsed output</p>

<p>```js
var processor = parser();</p>

<p>var result = processor.process(‘ .class’).result;
// =>  .class</p>

<p>// To have the parser normalize whitespace values, utilize the options
var result = processor.process(‘  .class  ‘, {lossless: false}).result;
// => .class
```</p>

<p>Arguments:</p>

<ul>
  <li><code>cssText (string)</code>: The css to be parsed.</li>
  <li><code>[options] (object)</code>: Process options</li>
</ul>

<p>Options:</p>

<ul>
  <li><code>lossless (boolean)</code>: false to normalize the selector whitespace, defaults to true</li>
</ul>