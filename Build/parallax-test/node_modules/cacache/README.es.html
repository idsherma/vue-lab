<h1>cacache <a href="https://npm.im/cacache"><img src="https://img.shields.io/npm/v/cacache.svg" alt="npm version" /></a> <a href="https://npm.im/cacache"><img src="https://img.shields.io/npm/l/cacache.svg" alt="license" /></a> <a href="https://travis-ci.org/zkat/cacache"><img src="https://img.shields.io/travis/zkat/cacache.svg" alt="Travis" /></a> <a href="https://ci.appveyor.com/project/zkat/cacache"><img src="https://ci.appveyor.com/api/projects/status/github/zkat/cacache?svg=true" alt="AppVeyor" /></a> <a href="https://coveralls.io/github/zkat/cacache?branch=latest"><img src="https://coveralls.io/repos/github/zkat/cacache/badge.svg?branch=latest" alt="Coverage Status" /></a></h1>

<p><a href="https://github.com/zkat/cacache"><code>cacache</code></a> es una librer√≠a de Node.js para
manejar caches locales en disco, con acceso tanto con claves √∫nicas como
direcciones de contenido (hashes/hacheos). Es s√∫per r√°pida, excelente con el
acceso concurrente, y jam√°s te dar√° datos incorrectos, a√∫n si se corrompen o
manipulan directamente los ficheros del cache.</p>

<p>El prop√≥sito original era reemplazar el cach√© local de
<a href="https://npm.im/npm">npm</a>, pero se puede usar por su propia cuenta.</p>

<p><em>Traducciones: <a href="README.md">English</a></em></p>

<h2>Instalaci√≥n</h2>

<p><code>$ npm install --save cacache</code></p>

<h2>√çndice</h2>

<ul>
  <li><a href="#ejemplo">Ejemplo</a></li>
  <li><a href="#caracter√≠sticas">Caracter√≠sticas</a></li>
  <li><a href="#c√≥mo-contribuir">C√≥mo Contribuir</a></li>
  <li><a href="#api">API</a>
    <ul>
      <li><a href="#localized-api">Usando el API en espa√±ol</a></li>
      <li>Leer
        <ul>
          <li><a href="#ls"><code>ls</code></a></li>
          <li><a href="#ls-stream"><code>ls.flujo</code></a></li>
          <li><a href="#get-data"><code>saca</code></a></li>
          <li><a href="#get-stream"><code>saca.flujo</code></a></li>
          <li><a href="#get-info"><code>saca.info</code></a></li>
          <li><a href="#get-hasContent"><code>saca.tieneDatos</code></a></li>
        </ul>
      </li>
      <li>Escribir
        <ul>
          <li><a href="#put-data"><code>mete</code></a></li>
          <li><a href="#put-stream"><code>mete.flujo</code></a></li>
          <li><a href="#put-options">opciones para <code>mete*</code></a></li>
          <li><a href="#rm-all"><code>rm.todo</code></a></li>
          <li><a href="#rm-entry"><code>rm.entrada</code></a></li>
          <li><a href="#rm-content"><code>rm.datos</code></a></li>
        </ul>
      </li>
      <li>Utilidades
        <ul>
          <li><a href="#set-locale"><code>ponLenguaje</code></a></li>
          <li><a href="#clear-memoized"><code>limpiaMemoizado</code></a></li>
          <li><a href="#tmp-mkdir"><code>tmp.hazdir</code></a></li>
          <li><a href="#with-tmp"><code>tmp.conTmp</code></a></li>
        </ul>
      </li>
      <li>Integridad
        <ul>
          <li><a href="#integrity">Subresource Integrity</a></li>
          <li><a href="#verify"><code>verifica</code></a></li>
          <li><a href="#verify-last-run"><code>verifica.ultimaVez</code></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3>Ejemplo</h3>

<p>```javascript
const cacache = require(‚Äòcacache/es‚Äô)
const fs = require(‚Äòfs‚Äô)</p>

<p>const tarbol = ‚Äò/ruta/a/mi-tar.tgz‚Äô
const rutaCache = ‚Äò/tmp/my-toy-cache‚Äô
const clave = ‚Äòmi-clave-√∫nica-1234‚Äô</p>

<p>// ¬°A√±√°delo al cach√©! Usa <code>rutaCache</code> como ra√≠z del cach√©.
cacache.mete(rutaCache, clave, ‚Äò10293801983029384‚Äô).then(integrity => {
  console.log(<code>Saved content to ${rutaCache}.</code>)
})</p>

<p>const destino = ‚Äò/tmp/mytar.tgz‚Äô</p>

<p>// Copia el contenido del cach√© a otro fichero, pero esta vez con flujos.
cacache.saca.flujo(
  rutaCache, clave
).pipe(
  fs.createWriteStream(destino)
).on(‚Äòfinish‚Äô, () => {
  console.log(‚Äòextracci√≥n completada‚Äô)
})</p>

<p>// La misma cosa, pero accesando el contenido directamente, sin tocar el √≠ndice.
cacache.saca.porHacheo(rutaCache, integridad).then(datos => {
  fs.writeFile(destino, datos, err => {
    console.log(‚Äòdatos del tarbol sacados basado en su sha512, y escrito a otro fichero‚Äô)
  })
})
```</p>

<h3>Caracter√≠sticas</h3>

<ul>
  <li>Extracci√≥n por clave o por direcci√≥n de contenido (shasum, etc)</li>
  <li>Usa el est√°ndard de web, <a href="#integrity">Subresource Integrity</a></li>
  <li>Compatible con multiples algoritmos - usa sha1, sha512, etc, en el mismo cach√© sin problema</li>
  <li>Entradas con contenido id√©ntico comparten ficheros</li>
  <li>Tolerancia de fallas (inmune a corrupci√≥n, ficheros parciales, carreras de proceso, etc)</li>
  <li>Verificaci√≥n completa de datos cuando (escribiendo y leyendo)</li>
  <li>Concurrencia r√°pida, segura y ‚Äúlockless‚Äù</li>
  <li>Compatible con <code>stream</code>s (flujos)</li>
  <li>Compatible con <code>Promise</code>s (promesas)</li>
  <li>Bastante r√°pida ‚Äì acceso, incluyendo verificaci√≥n, en microsegundos</li>
  <li>Almacenaje de metadatos arbitrarios</li>
  <li>Colecci√≥n de basura y verificaci√≥n adicional fuera de banda</li>
  <li>Cobertura rigurosa de pruebas</li>
  <li>Probablente hay un ‚ÄúBloom filter‚Äù por ah√≠ en alg√∫n lado. Eso le mola a la gente, ¬øVerdad? ü§î</li>
</ul>

<h3>C√≥mo Contribuir</h3>

<p>El equipo de cacache felizmente acepta contribuciones de c√≥digo y otras maneras de participaci√≥n. ¬°Hay muchas formas diferentes de contribuir! La <a href="CONTRIBUTING.md">Gu√≠a de Colaboradores</a> (en ingl√©s) tiene toda la informaci√≥n que necesitas para cualquier tipo de contribuci√≥n: todo desde c√≥mo reportar errores hasta c√≥mo someter parches con nuevas caracter√≠sticas. Con todo y eso, no se preocupe por si lo que haces est√° ex√°ctamente correcto: no hay ning√∫n problema en hacer preguntas si algo no est√° claro, o no lo encuentras.</p>

<p>El equipo de cacache tiene miembros hispanohablantes: es completamente aceptable crear <code>issues</code> y <code>pull requests</code> en espa√±ol/castellano.</p>

<p>Todos los participantes en este proyecto deben obedecer el <a href="CODE_OF_CONDUCT.md">C√≥digo de Conducta</a> (en ingl√©s), y en general actuar de forma amable y respetuosa mientras participan en esta comunidad.</p>

<p>Por favor refi√©rase al <a href="CHANGELOG.md">Historial de Cambios</a> (en ingl√©s) para detalles sobre cambios importantes inclu√≠dos en cada versi√≥n.</p>

<p>Finalmente, cacache tiene un sistema de localizaci√≥n de lenguaje. Si te interesa a√±adir lenguajes o mejorar los que existen, mira en el directorio <code>./locales</code> para comenzar.</p>

<p>Happy hacking!</p>

<h3>API</h3>

<h4><a name="localized-api"></a> Usando el API en espa√±ol</h4>

<p>cacache incluye una traducci√≥n completa de su API al castellano, con las mismas
caracter√≠sticas. Para usar el API como est√° documentado en este documento, usa
<code>require('cacache/es')</code></p>

<p>cacache tambi√©n tiene otros lenguajes: encu√©ntralos bajo <code>./locales</code>, y podr√°s
usar el API en ese lenguaje con <code>require('cacache/<lenguaje>')</code></p>

<h4><a name="ls"></a> <code>> cacache.ls(cache) -> Promise<Object></code></h4>

<p>Enumera todas las entradas en el cach√©, dentro de un solo objeto. Cada entrada
en el objeto tendr√° como clave la clave √∫nica usada para el √≠ndice, el valor
siendo un objeto de <a href="#get-info"><code>saca.info</code></a>.</p>

<h5>Ejemplo</h5>

<p><code>javascript
cacache.ls(rutaCache).then(console.log)
// Salida
{
  'my-thing': {
    key: 'my-thing',
    integrity: 'sha512-BaSe64/EnCoDED+HAsh=='
    path: '.testcache/content/deadbeef', // unido con `rutaCache`
    time: 12345698490,
    size: 4023948,
    metadata: {
      name: 'blah',
      version: '1.2.3',
      description: 'this was once a package but now it is my-thing'
    }
  },
  'other-thing': {
    key: 'other-thing',
    integrity: 'sha1-ANothER+hasH=',
    path: '.testcache/content/bada55',
    time: 11992309289,
    size: 111112
  }
}
</code></p>

<h4><a name="ls-stream"></a> <code>> cacache.ls.flujo(cache) -> Readable</code></h4>

<p>Enumera todas las entradas en el cach√©, emitiendo un objeto de
<a href="#get-info"><code>saca.info</code></a> por cada evento de <code>data</code> en el flujo.</p>

<h5>Ejemplo</h5>

<p>```javascript
cacache.ls.flujo(rutaCache).on(‚Äòdata‚Äô, console.log)
// Salida
{
  key: ‚Äòmy-thing‚Äô,
  integrity: ‚Äòsha512-BaSe64HaSh‚Äô,
  path: ‚Äò.testcache/content/deadbeef‚Äô, // unido con <code>rutaCache</code>
  time: 12345698490,
  size: 13423,
  metadata: {
    name: ‚Äòblah‚Äô,
    version: ‚Äò1.2.3‚Äô,
    description: ‚Äòthis was once a package but now it is my-thing‚Äô
  }
}</p>

<p>{
  key: ‚Äòother-thing‚Äô,
  integrity: ‚Äòwhirlpool-WoWSoMuchSupport‚Äô,
  path: ‚Äò.testcache/content/bada55‚Äô,
  time: 11992309289,
  size: 498023984029
}</p>

<p>{
  ‚Ä¶
}
```</p>

<h4><a name="get-data"></a> <code>> cacache.saca(cache, clave, [ops]) -> Promise({data, metadata, integrity})</code></h4>

<p>Devuelve un objeto con los datos, hacheo de integridad y metadatos identificados
por la <code>clave</code>. La propiedad <code>data</code> de este objeto ser√° una instancia de
<code>Buffer</code> con los datos almacenados en el cach√©. to do with it! cacache just
won‚Äôt care.</p>

<p><code>integrity</code> es un <code>string</code> de <a href="#integrity">Subresource Integrity</a>. D√≠gase, un
<code>string</code> que puede ser usado para verificar a la <code>data</code>, que tiene como formato
<code><algoritmo>-<hacheo-integridad-base64></code>.</p>

<p>So no existe ninguna entrada identificada por <code>clave</code>, o se los datos
almacenados localmente fallan verificaci√≥n, el <code>Promise</code> fallar√°.</p>

<p>Una sub-funci√≥n, <code>saca.porHacheo</code>, tiene casi el mismo comportamiento, excepto
que busca entradas usando el hacheo de integridad, sin tocar el √≠ndice general.
Esta versi√≥n <em>s√≥lo</em> devuelve <code>data</code>, sin ning√∫n objeto conteni√©ndola.</p>

<h5>Nota</h5>

<p>Esta funci√≥n lee la entrada completa a la memoria antes de devolverla. Si est√°s
almacenando datos Muy Grandes, es posible que <a href="#get-stream"><code>saca.flujo</code></a> sea
una mejor soluci√≥n.</p>

<h5>Ejemplo</h5>

<p>```javascript
// Busca por clave
cache.saca(rutaCache, ‚Äòmy-thing‚Äô).then(console.log)
// Salida:
{
  metadata: {
    thingName: ‚Äòmy‚Äô
  },
  integrity: ‚Äòsha512-BaSe64HaSh‚Äô,
  data: Buffer#<deadbeef>,
  size: 9320
}</deadbeef></p>

<p>// Busca por hacheo
cache.saca.porHacheo(rutaCache, ‚Äòsha512-BaSe64HaSh‚Äô).then(console.log)
// Salida:
Buffer#<deadbeef>
```</deadbeef></p>

<h4><a name="get-stream"></a> <code>> cacache.saca.flujo(cache, clave, [ops]) -> Readable</code></h4>

<p>Devuelve un <a href="https://nodejs.org/api/stream.html#stream_readable_streams">Readable
Stream</a> de los datos
almacenados bajo <code>clave</code>.</p>

<p>So no existe ninguna entrada identificada por <code>clave</code>, o se los datos
almacenados localmente fallan verificaci√≥n, el <code>Promise</code> fallar√°.</p>

<p><code>metadata</code> y <code>integrity</code> ser√°n emitidos como eventos antes de que el flujo
cierre.</p>

<p>Una sub-funci√≥n, <code>saca.flujo.porHacheo</code>, tiene casi el mismo comportamiento,
excepto que busca entradas usando el hacheo de integridad, sin tocar el √≠ndice
general. Esta versi√≥n no emite eventos de <code>metadata</code> o <code>integrity</code>.</p>

<h5>Ejemplo</h5>

<p>```javascript
// Busca por clave
cache.saca.flujo(
  rutaCache, ‚Äòmy-thing‚Äô
).on(‚Äòmetadata‚Äô, metadata => {
  console.log(‚Äòmetadata:‚Äô, metadata)
}).on(‚Äòintegrity‚Äô, integrity => {
  console.log(‚Äòintegrity:‚Äô, integrity)
}).pipe(
  fs.createWriteStream(‚Äò./x.tgz‚Äô)
)
// Salidas:
metadata: { ‚Ä¶ }
integrity: ‚Äòsha512-SoMeDIGest+64==‚Äô</p>

<p>// Busca por hacheo
cache.saca.flujo.porHacheo(
  rutaCache, ‚Äòsha512-SoMeDIGest+64==‚Äô
).pipe(
  fs.createWriteStream(‚Äò./x.tgz‚Äô)
)
```</p>

<h4><a name="get-info"></a> <code>> cacache.saca.info(cache, clave) -> Promise</code></h4>

<p>Busca la <code>clave</code> en el √≠ndice del cach√©, devolviendo informaci√≥n sobre la
entrada si existe.</p>

<h5>Campos</h5>

<ul>
  <li><code>key</code> - Clave de la entrada. Igual al argumento <code>clave</code>.</li>
  <li><code>integrity</code> - <a href="#integrity">hacheo de Subresource Integrity</a> del contenido al que se refiere esta entrada.</li>
  <li><code>path</code> - Direcci√≥n del fichero de datos almacenados, relativa al argumento <code>cache</code>.</li>
  <li><code>time</code> - Hora de creaci√≥n de la entrada</li>
  <li><code>metadata</code> - Metadatos asignados a esta entrada por el usuario</li>
</ul>

<h5>Ejemplo</h5>

<p>```javascript
cacache.saca.info(rutaCache, ‚Äòmy-thing‚Äô).then(console.log)</p>

<p>// Salida
{
  key: ‚Äòmy-thing‚Äô,
  integrity: ‚Äòsha256-MUSTVERIFY+ALL/THINGS==‚Äô
  path: ‚Äò.testcache/content/deadbeef‚Äô,
  time: 12345698490,
  size: 849234,
  metadata: {
    name: ‚Äòblah‚Äô,
    version: ‚Äò1.2.3‚Äô,
    description: ‚Äòthis was once a package but now it is my-thing‚Äô
  }
}
```</p>

<h4><a name="get-hasContent"></a> <code>> cacache.saca.tieneDatos(cache, integrity) -> Promise</code></h4>

<p>Busca un <a href="#integrity">hacheo Subresource Integrity</a> en el cach√©. Si existe el
contenido asociado con <code>integrity</code>, devuelve un objeto con dos campos: el hacheo
<em>espec√≠fico</em> que se us√≥ para la b√∫squeda, <code>sri</code>, y el tama√±o total del
contenido, <code>size</code>. Si no existe ning√∫n contenido asociado con <code>integrity</code>,
devuelve <code>false</code>.</p>

<h5>Ejemplo</h5>

<p>```javascript
cacache.saca.tieneDatos(rutaCache, ‚Äòsha256-MUSTVERIFY+ALL/THINGS==‚Äô).then(console.log)</p>

<p>// Salida
{
  sri: {
    source: ‚Äòsha256-MUSTVERIFY+ALL/THINGS==‚Äô,
    algorithm: ‚Äòsha256‚Äô,
    digest: ‚ÄòMUSTVERIFY+ALL/THINGS==‚Äô,
    options: []
  },
  size: 9001
}</p>

<p>cacache.saca.tieneDatos(rutaCache, ‚Äòsha521-NOT+IN/CACHE==‚Äô).then(console.log)</p>

<p>// Salida
false
```</p>

<h4><a name="put-data"></a> <code>> cacache.mete(cache, clave, datos, [ops]) -> Promise</code></h4>

<p>Inserta <code>datos</code> en el cach√©. El <code>Promise</code> devuelto se resuelve con un hacheo
(generado conforme a <a href="#optsalgorithms"><code>ops.algorithms</code></a>) despu√©s que la entrada
haya sido escrita en completo.</p>

<h5>Ejemplo</h5>

<p><code>javascript
fetch(
  'https://registry.npmjs.org/cacache/-/cacache-1.0.0.tgz'
).then(datos => {
  return cacache.mete(rutaCache, 'registry.npmjs.org|cacache@1.0.0', datos)
}).then(integridad => {
  console.log('el hacheo de integridad es', integridad)
})
</code></p>

<h4><a name="put-stream"></a> <code>> cacache.mete.flujo(cache, clave, [ops]) -> Writable</code></h4>

<p>Devuelve un <a href="https://nodejs.org/api/stream.html#stream_writable_streams">Writable
Stream</a> que inserta
al cach√© los datos escritos a √©l. Emite un evento <code>integrity</code> con el hacheo del
contenido escrito, cuando completa.</p>

<h5>Ejemplo</h5>

<p><code>javascript
request.get(
  'https://registry.npmjs.org/cacache/-/cacache-1.0.0.tgz'
).pipe(
  cacache.mete.flujo(
    rutaCache, 'registry.npmjs.org|cacache@1.0.0'
  ).on('integrity', d => console.log(`integrity digest is ${d}`))
)
</code></p>

<h4><a name="put-options"></a> <code>> opciones para cacache.mete</code></h4>

<p>La funciones <code>cacache.mete</code> tienen un n√∫mero de opciones en com√∫n.</p>

<h5><code>ops.metadata</code></h5>

<p>Metadatos del usuario que se almacenar√°n con la entrada.</p>

<h5><code>ops.size</code></h5>

<p>El tama√±o declarado de los datos que se van a insertar. Si es prove√≠do, cacache
verificar√° que los datos escritos sean de ese tama√±o, o si no, fallar√° con un
error con c√≥digo <code>EBADSIZE</code>.</p>

<h5><code>ops.integrity</code></h5>

<p>El hacheo de integridad de los datos siendo escritos.</p>

<p>Si es prove√≠do, y los datos escritos no le corresponden, la operaci√≥n fallar√°
con un error con c√≥digo <code>EINTEGRITY</code>.</p>

<p><code>ops.algorithms</code> no tiene ning√∫n efecto si esta opci√≥n est√° presente.</p>

<h5><code>ops.algorithms</code></h5>

<p>Por Defecto: <code>['sha512']</code></p>

<p>Algoritmos que se deben usar cuando se calcule el hacheo de <a href="#integrity">subresource
integrity</a> para los datos insertados. Puede usar cualquier algoritmo
enumerado en <code>crypto.getHashes()</code>.</p>

<p>Por el momento, s√≥lo se acepta un algoritmo (d√≠gase, un array con ex√°ctamente un
valor). No tiene ning√∫n efecto si <code>ops.integrity</code> tambi√©n ha sido proveido.</p>

<h5><code>ops.uid</code>/<code>ops.gid</code></h5>

<p>Si est√°n presentes, cacache har√° todo lo posible para asegurarse que todos los
ficheros creados en el proceso de sus operaciones en el cach√© usen esta
combinaci√≥n en particular.</p>

<h5><code>ops.memoize</code></h5>

<p>Por Defecto: <code>null</code></p>

<p>Si es verdad, cacache tratar√° de memoizar los datos de la entrada en memoria. La
pr√≥xima vez que el proceso corriente trate de accesar los datos o entrada,
cacache buscar√° en memoria antes de buscar en disco.</p>

<p>Si <code>ops.memoize</code> es un objeto regular o un objeto como <code>Map</code> (es decir, un
objeto con m√©todos <code>get()</code> y <code>set()</code>), este objeto en s√≠ sera usado en vez del
cach√© de memoria global. Esto permite tener l√≥gica espec√≠fica a tu aplicaci√≥n
encuanto al almacenaje en memoria de tus datos.</p>

<p>Si quieres asegurarte que los datos se lean del disco en vez de memoria, usa
<code>memoize: false</code> cuando uses funciones de <code>cacache.saca</code>.</p>

<h4><a name="rm-all"></a> <code>> cacache.rm.todo(cache) -> Promise</code></h4>

<p>Borra el cach√© completo, incluyendo ficheros temporeros, ficheros de datos, y el
√≠ndice del cach√©.</p>

<h5>Ejemplo</h5>

<p><code>javascript
cacache.rm.todo(rutaCache).then(() => {
  console.log('THE APOCALYPSE IS UPON US üò±')
})
</code></p>

<h4><a name="rm-entry"></a> <code>> cacache.rm.entrada(cache, clave) -> Promise</code></h4>

<p>Alias: <code>cacache.rm</code></p>

<p>Borra la entrada <code>clave</code> del √≠nduce. El contenido asociado con esta entrada
seguir√° siendo accesible por hacheo usando
<a href="#get-stream"><code>saca.flujo.porHacheo</code></a>.</p>

<p>Para borrar el contenido en s√≠, usa <a href="#rm-content"><code>rm.datos</code></a>. Si quieres hacer
esto de manera m√°s segura (pues ficheros de contenido pueden ser usados por
multiples entradas), usa <a href="#verify"><code>verifica</code></a> para borrar hu√©rfanos.</p>

<h5>Ejemplo</h5>

<p><code>javascript
cacache.rm.entrada(rutaCache, 'my-thing').then(() => {
  console.log('I did not like it anyway')
})
</code></p>

<h4><a name="rm-content"></a> <code>> cacache.rm.datos(cache, integrity) -> Promise</code></h4>

<p>Borra el contenido identificado por <code>integrity</code>. Cualquier entrada que se
refiera a este contenido quedar√°n hu√©rfanas y se invalidar√°n si se tratan de
accesar, al menos que contenido id√©ntico sea a√±adido bajo <code>integrity</code>.</p>

<h5>Ejemplo</h5>

<p><code>javascript
cacache.rm.datos(rutaCache, 'sha512-SoMeDIGest/IN+BaSE64==').then(() => {
  console.log('los datos para `mi-cosa` se borraron')
})
</code></p>

<h4><a name="set-locale"></a> <code>> cacache.ponLenguaje(locale)</code></h4>

<p>Configura el lenguaje usado para mensajes y errores de cacache. La lista de
lenguajes disponibles est√° en el directorio <code>./locales</code> del proyecto.</p>

<p><em>Te interesa a√±adir m√°s lenguajes? <a href="CONTRIBUTING.md">Somete un PR</a>!</em></p>

<h4><a name="clear-memoized"></a> <code>> cacache.limpiaMemoizado()</code></h4>

<p>Completamente reinicializa el cach√© de memoria interno. Si est√°s usando tu
propio objecto con <code>ops.memoize</code>, debes hacer esto de manera espec√≠fica a √©l.</p>

<h4><a name="tmp-mkdir"></a> <code>> tmp.hazdir(cache, ops) -> Promise<Path></code></h4>

<p>Alias: <code>tmp.mkdir</code></p>

<p>Devuelve un directorio √∫nico dentro del directorio <code>tmp</code> del cach√©.</p>

<p>Una vez tengas el directorio, es responsabilidad tuya asegurarte que todos los
ficheros escrito a √©l sean creados usando los permisos y <code>uid</code>/<code>gid</code> concordante
con el cach√©. Si no, puedes pedirle a cacache que lo haga llamando a
<a href="#tmp-fix"><code>cacache.tmp.fix()</code></a>. Esta funci√≥n arreglar√° todos los permisos en el
directorio tmp.</p>

<p>Si quieres que cacache limpie el directorio autom√°ticamente cuando termines, usa
<a href="#with-tpm"><code>cacache.tmp.conTmp()</code></a>.</p>

<h5>Ejemplo</h5>

<p><code>javascript
cacache.tmp.mkdir(cache).then(dir => {
  fs.writeFile(path.join(dir, 'blablabla'), Buffer#<1234>, ...)
})
</code></p>

<h4><a name="with-tmp"></a> <code>> tmp.conTmp(cache, ops, cb) -> Promise</code></h4>

<p>Crea un directorio temporero con <a href="#tmp-mkdir"><code>tmp.mkdir()</code></a> y ejecuta <code>cb</code> con
√©l como primer argumento. El directorio creado ser√° removido autom√°ticamente
cuando el valor devolvido por <code>cb()</code> se resuelva.</p>

<p>Las mismas advertencias aplican en cuanto a manejando permisos para los ficheros
dentro del directorio.</p>

<h5>Ejemplo</h5>

<p><code>javascript
cacache.tmp.conTmp(cache, dir => {
  return fs.writeFileAsync(path.join(dir, 'blablabla'), Buffer#<1234>, ...)
}).then(() => {
  // `dir` no longer exists
})
</code></p>

<h4><a name="integrity"></a> Hacheos de Subresource Integrity</h4>

<p>cacache usa strings que siguen la especificaci√≥n de <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity
spec</a>.</p>

<p>Es decir, donde quiera cacache espera un argumento o opci√≥n <code>integrity</code>, ese
string deber√≠a usar el formato <code><algoritmo>-<hacheo-base64></code>.</p>

<p>Una variaci√≥n importante sobre los hacheos que cacache acepta es que acepta el
nombre de cualquier algoritmo aceptado por el proceso de Node.js donde se usa.
Puedes usar <code>crypto.getHashes()</code> para ver cuales est√°n disponibles.</p>

<h5>Generando tus propios hacheos</h5>

<p>Si tienes un <code>shasum</code>, en general va a estar en formato de string hexadecimal
(es decir, un <code>sha1</code> se ver√≠a como algo as√≠:
<code>5f5513f8822fdbe5145af33b64d8d970dcf95c6e</code>).</p>

<p>Para ser compatible con cacache, necesitas convertir esto a su equivalente en
subresource integrity. Por ejemplo, el hacheo correspondiente al ejemplo
anterior ser√≠a: <code>sha1-X1UT+IIv2+UUWvM7ZNjZcNz5XG4=</code>.</p>

<p>Puedes usar c√≥digo as√≠ para generarlo por tu cuenta:</p>

<p>```javascript
const crypto = require(‚Äòcrypto‚Äô)
const algoritmo = ‚Äòsha512‚Äô
const datos = ‚Äòfoobarbaz‚Äô</p>

<p>const integrity = (
  algorithm +
  ‚Äò-‚Äò +
  crypto.createHash(algoritmo).update(datos).digest(‚Äòbase64‚Äô)
)
```</p>

<p>Tambi√©n puedes usar <a href="https://npm.im/ssri"><code>ssri</code></a> para deferir el trabajo a otra
librer√≠a que garantiza que todo est√© correcto, pues maneja probablemente todas
las operaciones que tendr√≠as que hacer con SRIs, incluyendo convirtiendo entre
hexadecimal y el formato SRI.</p>

<h4><a name="verify"></a> <code>> cacache.verifica(cache, ops) -> Promise</code></h4>

<p>Examina y arregla tu cach√©:</p>

<ul>
  <li>Limpia entradas inv√°lidas, hu√©rfanas y corrompidas</li>
  <li>Te deja filtrar cuales entradas retener, con tu propio filtro</li>
  <li>Reclama cualquier ficheros de contenido sin referencias en el √≠ndice</li>
  <li>Verifica integridad de todos los ficheros de contenido y remueve los malos</li>
  <li>Arregla permisos del cach√©</li>
  <li>Remieve el directorio <code>tmp</code> en el cach√©, y todo su contenido.</li>
</ul>

<p>Cuando termine, devuelve un objeto con varias estad√≠sticas sobre el proceso de
verificaci√≥n, por ejemplo la cantidad de espacio de disco reclamado, el n√∫mero
de entradas v√°lidas, n√∫mero de entradas removidas, etc.</p>

<h5>Opciones</h5>

<ul>
  <li><code>ops.uid</code> - uid para asignarle al cach√© y su contenido</li>
  <li><code>ops.gid</code> - gid para asignarle al cach√© y su contenido</li>
  <li><code>ops.filter</code> - recibe una entrada como argumento. Devuelve falso para removerla. Nota: es posible que esta funci√≥n sea invocada con la misma entrada m√°s de una vez.</li>
</ul>

<h5>Example</h5>

<p><code>sh
echo somegarbage >> $RUTACACHE/content/deadbeef
</code></p>

<p><code>javascript
cacache.verifica(rutaCache).then(stats => {
  // deadbeef collected, because of invalid checksum.
  console.log('cache is much nicer now! stats:', stats)
})
</code></p>

<h4><a name="verify-last-run"></a> <code>> cacache.verifica.ultimaVez(cache) -> Promise</code></h4>

<p>Alias: <code>√∫ltimaVez</code></p>

<p>Devuelve un <code>Date</code> que representa la √∫ltima vez que <code>cacache.verifica</code> fue
ejecutada en <code>cache</code>.</p>

<h5>Example</h5>

<p><code>javascript
cacache.verifica(rutaCache).then(() => {
  cacache.verifica.ultimaVez(rutaCache).then(√∫ltima => {
    console.log('La √∫ltima vez que se us√≥ cacache.verifica() fue ' + √∫ltima)
  })
})
</code></p>