<h1>babel-plugin-transform-runtime</h1>

<blockquote>
  <p>Externalise references to helpers and builtins, automatically polyfilling your code without polluting globals. (This plugin is recommended in a library/tool)</p>
</blockquote>

<p>NOTE: Instance methods such as <code>"foobar".includes("foo")</code> will not work since that would require modification of existing builtins (Use <a href="http://babeljs.io/docs/usage/polyfill"><code>babel-polyfill</code></a> for that).</p>

<h2>Why?</h2>

<p>Babel uses very small helpers for common functions such as <code>_extend</code>. By default this will be added to every file that requires it. This duplication is sometimes unnecessary, especially when your application is spread out over multiple files.</p>

<p>This is where the <code>transform-runtime</code> plugin comes in: all of the helpers will reference the module <code>babel-runtime</code> to avoid duplication across your compiled output. The runtime will be compiled into your build.</p>

<p>Another purpose of this transformer is to create a sandboxed environment for your code. If you use <a href="http://babeljs.io/docs/usage/polyfill/">babel-polyfill</a> and the built-ins it provides such as <code>Promise</code>, <code>Set</code> and <code>Map</code>, those will pollute the global scope. While this might be ok for an app or a command line tool, it becomes a problem if your code is a library which you intend to publish for others to use or if you can’t exactly control the environment in which your code will run.</p>

<p>The transformer will alias these built-ins to <code>core-js</code> so you can use them seamlessly without having to require the polyfill.</p>

<p>See the <a href="#technical-details">technical details</a> section for more information on how this works and the types of transformations that occur.</p>

<h2>Installation</h2>

<p><strong>NOTE - Production vs. development dependencies</strong></p>

<p>In most cases, you should install <code>babel-plugin-transform-runtime</code> as a development dependency (with <code>--save-dev</code>).</p>

<p><code>sh
npm install --save-dev babel-plugin-transform-runtime
</code></p>

<p>and <code>babel-runtime</code> as a production dependency (with <code>--save</code>).</p>

<p><code>sh
npm install --save babel-runtime
</code></p>

<p>The transformation plugin is typically used only in development, but the runtime itself will be depended on by your deployed/published code. See the examples below for more details.</p>

<h2>Usage</h2>

<h3>Via <code>.babelrc</code> (Recommended)</h3>

<p>Add the following line to your <code>.babelrc</code> file:</p>

<p>```js
// without options
{
  “plugins”: [“transform-runtime”]
}</p>

<p>// with options
{
  “plugins”: [
    [“transform-runtime”, {
      “helpers”: false, // defaults to true
      “polyfill”: false, // defaults to true
      “regenerator”: true, // defaults to true
      “moduleName”: “babel-runtime” // defaults to “babel-runtime”
    }]
  ]
}
```</p>

<h3>Via CLI</h3>

<p><code>sh
babel --plugins transform-runtime script.js
</code></p>

<h3>Via Node API</h3>

<p><code>javascript
require("babel-core").transform("code", {
  plugins: ["transform-runtime"]
});
</code></p>

<h2>Technical details</h2>

<p>The <code>runtime</code> transformer plugin does three things:</p>

<ul>
  <li>Automatically requires <code>babel-runtime/regenerator</code> when you use generators/async functions.</li>
  <li>Automatically requires <code>babel-runtime/core-js</code> and maps ES6 static methods and built-ins.</li>
  <li>Removes the inline babel helpers and uses the module <code>babel-runtime/helpers</code> instead.</li>
</ul>

<p>What does this actually mean though? Basically, you can use built-ins such as <code>Promise</code>, <code>Set</code>, <code>Symbol</code> etc as well use all the Babel features that require a polyfill seamlessly, without global pollution, making it extremely suitable for libraries.</p>

<p>Make sure you include <code>babel-runtime</code> as a dependency.</p>

<h3>Regenerator aliasing</h3>

<p>Whenever you use a generator function or async function:</p>

<p>```javascript
function* foo() {</p>

<p>}
```</p>

<p>the following is generated:</p>

<p>```javascript
“use strict”;</p>

<p>var _marked = [foo].map(regeneratorRuntime.mark);</p>

<p>function foo() {
  return regeneratorRuntime.wrap(function foo$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
      case “end”:
        return _context.stop();
    }
  }, _marked[0], this);
}
```</p>

<p>This isn’t ideal as then you have to include the regenerator runtime which
pollutes the global scope.</p>

<p>Instead what the <code>runtime</code> transformer does it compile that to:</p>

<p>```javascript
“use strict”;</p>

<p>var _regenerator = require(“babel-runtime/regenerator”);</p>

<p>var _regenerator2 = _interopRequireDefault(_regenerator);</p>

<p>function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }</p>

<p>var _marked = [foo].map(_regenerator2.default.mark);</p>

<p>function foo() {
  return regeneratorRuntime.wrap(function foo$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
      case “end”:
        return _context.stop();
    }
  }, _marked[0], this);
}
```</p>

<p>This means that you can use the regenerator runtime without polluting your current environment.</p>

<h3><code>core-js</code> aliasing</h3>

<p>Sometimes you may want to use new built-ins such as <code>Map</code>, <code>Set</code>, <code>Promise</code> etc. Your only way
to use these is usually to include a globally polluting polyfill.</p>

<p>What the <code>runtime</code> transformer does is transform the following:</p>

<p>```javascript
var sym = Symbol();</p>

<p>var promise = new Promise;</p>

<p>console.log(arr<a href="">Symbol.iterator</a>);
```</p>

<p>into the following:</p>

<p>```javascript
“use strict”;</p>

<p>var _getIterator2 = require(“babel-runtime/core-js/get-iterator”);</p>

<p>var _getIterator3 = _interopRequireDefault(_getIterator2);</p>

<p>var _promise = require(“babel-runtime/core-js/promise”);</p>

<p>var _promise2 = _interopRequireDefault(_promise);</p>

<p>var _symbol = require(“babel-runtime/core-js/symbol”);</p>

<p>var _symbol2 = _interopRequireDefault(_symbol);</p>

<p>function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }</p>

<p>var sym = (0, _symbol2.default)();</p>

<p>var promise = new _promise2.default();</p>

<p>console.log((0, _getIterator3.default)(arr));
```</p>

<p>This means is that you can seamlessly use these native built-ins and static methods
without worrying about where they come from.</p>

<p><strong>NOTE:</strong> Instance methods such as <code>"foobar".includes("foo")</code> will <strong>not</strong> work.</p>

<h3>Helper aliasing</h3>

<p>Usually babel will place helpers at the top of your file to do common tasks to avoid
duplicating the code around in the current file. Sometimes these helpers can get a
little bulky and add unnecessary duplication across files. The <code>runtime</code>
transformer replaces all the helper calls to a module.</p>

<p>That means that the following code:</p>

<p><code>javascript
class Person {
}
</code></p>

<p>usually turns into:</p>

<p>```javascript
“use strict”;</p>

<p>function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } }</p>

<p>var Person = function Person() {
  _classCallCheck(this, Person);
};
```</p>

<p>the <code>runtime</code> transformer however turns this into:</p>

<p>```javascript
“use strict”;</p>

<p>var _classCallCheck2 = require(“babel-runtime/helpers/classCallCheck”);</p>

<p>var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);</p>

<p>function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }</p>

<p>var Person = function Person() {
  (0, _classCallCheck3.default)(this, Person);
};
```</p>