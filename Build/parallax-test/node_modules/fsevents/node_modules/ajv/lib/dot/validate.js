if(undefined==window.JST){window.JST={};} window.JST["validate"] = function(obj){var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('{{# def.definitions }}\n{{# def.errors }}\n{{# def.defaults }}\n{{# def.coerce }}\n\n{{ /**\n    * schema compilation (render) time:\n    * it = { schema, RULES, _validate, opts }\n    * it.validate - this template function,\n    *   it is used recursively to generate code for subschemas\n    *\n    * runtime:\n    * "validate" is a variable name to which this function will be assigned\n    * validateRef etc. are defined in the parent scope in index.js\n    */ }}\n\n{{ var $async = it.schema.$async === true; }}\n\n{{? it.isTop}}\n  {{\n    var $top = it.isTop\n      , $lvl = it.level = 0\n      , $dataLvl = it.dataLevel = 0\n      , $data = \'data\';\n    it.rootId = it.resolve.fullPath(it.root.schema.id);\n    it.baseId = it.baseId || it.rootId;\n    if ($async) {\n      it.async = true;\n      var $es7 = it.opts.async == \'es7\';\n      it.yieldAwait = $es7 ? \'await\' : \'yield\';\n    }\n    delete it.isTop;\n\n    it.dataPathArr = [undefined];\n  }}\n\n  var validate =\n  {{? $async }}\n    {{? $es7 }}\n      (async function\n    {{??}}\n      {{? it.opts.async == \'co*\'}}co.wrap{{?}}(function*\n    {{?}}\n  {{??}}\n    (function\n  {{?}}\n    (data, dataPath, parentData, parentDataProperty, rootData) {\n    \'use strict\';\n    var vErrors = null; {{ /* don\'t edit, used in replace */ }}\n    var errors = 0;     {{ /* don\'t edit, used in replace */ }}\n    if (rootData === undefined) rootData = data;\n{{??}}\n  {{\n    var $lvl = it.level\n      , $dataLvl = it.dataLevel\n      , $data = \'data\' + ($dataLvl || \'\');\n\n    if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);\n\n    if ($async && !it.async) throw new Error(\'async schema in sync schema\');\n  }}\n\n  var errs_{{=$lvl}} = errors;\n{{?}}\n\n{{\n  var $valid = \'valid\' + $lvl\n    , $breakOnError = !it.opts.allErrors\n    , $closingBraces1 = \'\'\n    , $closingBraces2 = \'\';\n\n  var $errorKeyword;\n  var $typeSchema = it.schema.type\n    , $typeIsArray = Array.isArray($typeSchema);\n}}\n\n{{## def.checkType:\n  {{\n    var $schemaPath = it.schemaPath + \'.type\'\n      , $errSchemaPath = it.errSchemaPath + \'/type\'\n      , $method = $typeIsArray ? \'checkDataTypes\' : \'checkDataType\';\n  }}\n\n  if ({{= it.util[$method]($typeSchema, $data, true) }}) {\n#}}\n\n{{? $typeSchema && it.opts.coerceTypes }}\n  {{ var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema); }}\n  {{? $coerceToTypes }}\n    {{# def.checkType }}\n      {{# def.coerceType }}\n    }\n  {{?}}\n{{?}}\n\n{{ var $refKeywords; }}\n{{? it.schema.$ref && ($refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, \'$ref\')) }}\n  {{? it.opts.extendRefs == \'fail\' }}\n    {{ throw new Error(\'$ref: validation keywords used in schema at path "\' + it.errSchemaPath + \'"\'); }}\n  {{?? it.opts.extendRefs == \'ignore\' }}\n    {{\n      $refKeywords = false;\n      console.log(\'$ref: keywords ignored in schema at path "\' + it.errSchemaPath + \'"\');\n    }}\n  {{?? it.opts.extendRefs !== true }}\n    {{ console.log(\'$ref: all keywords used in schema at path "\' + it.errSchemaPath + \'". It will change in the next major version, see issue #260. Use option { extendRefs: true } to keep current behaviour\'); }}\n  {{?}}\n{{?}}\n\n{{? it.schema.$ref && !$refKeywords }}\n  {{= it.RULES.all.$ref.code(it, \'$ref\') }}\n  {{? $breakOnError }}\n    }\n    if (errors === {{?$top}}0{{??}}errs_{{=$lvl}}{{?}}) {\n    {{ $closingBraces2 += \'}\'; }}\n  {{?}}\n{{??}}\n  {{~ it.RULES:$rulesGroup }}\n    {{? $shouldUseGroup($rulesGroup) }}\n      {{? $rulesGroup.type }}\n        if ({{= it.util.checkDataType($rulesGroup.type, $data) }}) {\n      {{?}}\n        {{? it.opts.useDefaults && !it.compositeRule }}\n          {{? $rulesGroup.type == \'object\' && it.schema.properties }}\n            {{# def.defaultProperties }}\n          {{?? $rulesGroup.type == \'array\' && Array.isArray(it.schema.items) }}\n            {{# def.defaultItems }}\n          {{?}}\n        {{?}}\n        {{~ $rulesGroup.rules:$rule }}\n          {{? $shouldUseRule($rule) }}\n            {{= $rule.code(it, $rule.keyword) }}\n            {{? $breakOnError }}\n              {{ $closingBraces1 += \'}\'; }}\n            {{?}}\n          {{?}}\n        {{~}}\n        {{? $breakOnError }}\n          {{= $closingBraces1 }}\n          {{ $closingBraces1 = \'\'; }}\n        {{?}}\n      {{? $rulesGroup.type }}\n        }\n        {{? $typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes }}\n          {{ var $typeChecked = true; }}\n          else {\n            {{\n              var $schemaPath = it.schemaPath + \'.type\'\n                , $errSchemaPath = it.errSchemaPath + \'/type\';\n            }}\n            {{# def.error:\'type\' }}\n          }\n        {{?}}\n      {{?}}\n\n      {{? $breakOnError }}\n        if (errors === {{?$top}}0{{??}}errs_{{=$lvl}}{{?}}) {\n        {{ $closingBraces2 += \'}\'; }}\n      {{?}}\n    {{?}}\n  {{~}}\n{{?}}\n\n{{? $typeSchema && !$typeChecked && !$coerceToTypes }}\n  {{# def.checkType }}\n    {{# def.error:\'type\' }}\n  }\n{{?}}\n\n{{? $breakOnError }} {{= $closingBraces2 }} {{?}}\n\n{{? $top }}\n    {{? $async }}\n      if (errors === 0) return true;           {{ /* don\'t edit, used in replace */ }}\n      else throw new ValidationError(vErrors); {{ /* don\'t edit, used in replace */ }}\n    {{??}}\n      validate.errors = vErrors; {{ /* don\'t edit, used in replace */ }}\n      return errors === 0;       {{ /* don\'t edit, used in replace */ }}\n    {{?}}\n  });\n\n  return validate;\n{{??}}\n  var {{=$valid}} = errors === errs_{{=$lvl}};\n{{?}}\n\n{{# def.cleanUp }}\n\n{{? $top && $breakOnError }}\n  {{# def.cleanUpVarErrors }}\n{{?}}\n\n{{\n  function $shouldUseGroup($rulesGroup) {\n    for (var i=0; i < $rulesGroup.rules.length; i++)\n      if ($shouldUseRule($rulesGroup.rules[i]))\n        return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined ||\n           ( $rule.keyword == \'properties\' &&\n             ( it.schema.additionalProperties === false ||\n               typeof it.schema.additionalProperties == \'object\'\n               || ( it.schema.patternProperties &&\n                    Object.keys(it.schema.patternProperties).length )\n               || ( it.opts.v5 && it.schema.patternGroups &&\n                    Object.keys(it.schema.patternGroups).length )));\n  }\n}}\n');}return __p.join('');}