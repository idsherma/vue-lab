<h1>dns-packet</h1>

<p>An <a href="https://github.com/mafintosh/abstract-encoding">abstract-encoding</a> compliant module for encoding / decoding DNS packets.
Lifted out of <a href="https://github.com/mafintosh/multicast-dns">multicast-dns</a> as a separate module.</p>

<p><code>
npm install dns-packet
</code></p>

<p><a href="https://travis-ci.org/mafintosh/dns-packet"><img src="https://travis-ci.org/mafintosh/dns-packet.svg?branch=master" alt="build status" /></a></p>

<h2>Usage</h2>

<p>``` js
var packet = require(‘dns-packet’)
var dgram = require(‘dgram’)</p>

<p>var socket = dgram.createSocket(‘udp4’)</p>

<p>var buf = packet.encode({
  type: ‘query’,
  id: 1,
  flags: packet.RECURSION_DESIRED,
  questions: [{
    type: ‘A’,
    name: ‘google.com’
  }]
})</p>

<p>socket.on(‘message’, function (message) {
  console.log(packet.decode(message)) // prints out a response from google dns
})</p>

<p>socket.send(buf, 0, buf.length, 53, ‘8.8.8.8’)
```</p>

<h2>API</h2>

<h4><code>var buf = packets.encode(packet, [buf], [offset])</code></h4>

<p>Encodes a DNS packet into a buffer.</p>

<h4><code>var packet = packets.decode(buf, [offset])</code></h4>

<p>Decode a DNS packet from a buffer</p>

<h4><code>var len = packets.encodingLength(packet)</code></h4>

<p>Returns how many bytes are needed to encode the DNS packet</p>

<h2>Packets</h2>

<p>Packets look like this</p>

<p><code>js
{
  type: 'query|response',
  id: optionalIdNumber,
  flags: optionalBitFlags,
  questions: [...],
  answers: [...],
  additionals: [...],
  authorities: [...]
}
</code></p>

<p>The bit flags available are</p>

<p><code>js
packet.RECURSION_DESIRED
packet.RECURSION_AVAILABLE
packet.TRUNCATED_RESPONSE
packet.AUTHORITATIVE_ANSWER
packet.AUTHENTIC_DATA
packet.CHECKING_DISABLED
</code></p>

<p>To use more than one flag bitwise-or them together</p>

<p><code>js
var flags = packet.RECURSION_DESIRED | packet.RECURSION_AVAILABLE
</code></p>

<p>And to check for a flag use bitwise-and</p>

<p><code>js
var isRecursive = message.flags & packet.RECURSION_DESIRED
</code></p>

<p>A question looks like this</p>

<p><code>js
{
  type: 'A', // or SRV, AAAA, etc
  name: 'google.com' // which record are you looking for
}
</code></p>

<p>And an answers, additional, or authority looks like this</p>

<p><code>js
{
  type: 'A', // or SRV, AAAA, etc
  name: 'google.com', // which name is this record for
  ttl: optionalTimeToLiveInSeconds,
  (record specific data, see below)
}
</code></p>

<p>Currently the different available records are</p>

<h4><code>A</code></h4>

<p><code>js
{
  data: 'IPv4 address' // fx 127.0.0.1
}
</code></p>

<h4><code>AAAA</code></h4>

<p><code>js
{
  data: 'IPv6 address' // fx fe80::1
}
</code></p>

<h4><code>TXT</code></h4>

<p><code>js
{
  data: Buffer('some text')
}
</code></p>

<h4><code>NULL</code></h4>

<p><code>js
{
  data: Buffer('any binary data')
}
</code></p>

<h4><code>SRV</code></h4>

<p><code>js
{
  data: {
    port: servicePort,
    target: serviceHostName,
    priority: optionalServicePriority,
    weight: optionalServiceWeight
  }
}
</code></p>

<h4><code>HINFO</code></h4>

<p><code>js
{
  data: {
    cpu: 'cpu info',
    os: 'os info'
  }
}
</code></p>

<h4><code>PTR</code></h4>

<p><code>js
{
  data: 'points.to.another.record'
}
</code></p>

<h4><code>CNAME</code></h4>

<p><code>js
{
  data: 'cname.to.another.record'
}
</code></p>

<h4><code>DNAME</code></h4>

<p><code>js
{
  data: 'dname.to.another.record'
}
</code></p>

<h4><code>CAA</code></h4>

<p><code>js
{
  flags: 128, // octet
  tag: 'issue|issuewild|iodef',
  value: 'ca.example.net'
}
</code></p>

<p>If you need another one, open an issue and we’ll try to add it.</p>

<h2>License</h2>

<p>MIT</p>