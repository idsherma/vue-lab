<h2>Object Wrappers</h2>

<p>The <code>ObjectWrap</code> class can be used to make wrapped C++ objects and a factory of wrapped objects.</p>

<ul>
  <li><a href="#api_nan_object_wrap"><b><code>Nan::ObjectWrap</code></b></a></li>
</ul>

<p><a name="api_nan_object_wrap"></a>
### Nan::ObjectWrap()</p>

<p>A reimplementation of <code>node::ObjectWrap</code> that adds some API not present in older versions of Node. Should be preferred over <code>node::ObjectWrap</code> in all cases for consistency.</p>

<p>Definition:</p>

<p>```c++
class ObjectWrap {
 public:
  ObjectWrap();</p>

<p>virtual ~ObjectWrap();</p>

<p>template <class t="">
  static inline T* Unwrap(v8::Local<v8::object> handle);</v8::object></class></p>

<p>inline v8::Local<v8::object> handle();</v8::object></p>

<p>inline Nan::Persistent<v8::object>& persistent();</v8::object></p>

<p>protected:
  inline void Wrap(v8::Local<v8::object> handle);</v8::object></p>

<p>inline void MakeWeak();</p>

<p>/* Ref() marks the object as being attached to an event loop.
   * Refed objects will not be garbage collected, even if
   * all references are lost.
   */
  virtual void Ref();</p>

<p>/* Unref() marks an object as detached from the event loop.  This is its
   * default state.  When an object with a “weak” reference changes from
   * attached to detached state it will be freed. Be careful not to access
   * the object after making this call as it might be gone!
   * (A “weak reference” means an object that only has a
   * persistant handle.)
   *
   * DO NOT CALL THIS FROM DESTRUCTOR
   */
  virtual void Unref();</p>

<p>int refs_;  // ro
};
```</p>

<p>See the Node documentation on <a href="https://nodejs.org/api/addons.html#addons_wrapping_c_objects">Wrapping C++ Objects</a> for more details.</p>

<h3>This vs. Holder</h3>

<p>When calling <code>Unwrap</code>, it is important that the argument is indeed some JavaScript object which got wrapped by a <code>Wrap</code> call for this class or any derived class.
The <code>Signature</code> installed by <a href="methods.md#api_nan_set_prototype_method"><code>Nan::SetPrototypeMethod()</code></a> does ensure that <code>info.Holder()</code> is just such an instance.
In Node 0.12 and later, <code>info.This()</code> will also be of such a type, since otherwise the invocation will get rejected.
However, in Node 0.10 and before it was possible to invoke a method on a JavaScript object which just had the extension type in its prototype chain.
In such a situation, calling <code>Unwrap</code> on <code>info.This()</code> will likely lead to a failed assertion causing a crash, but could lead to even more serious corruption.</p>

<p>On the other hand, calling <code>Unwrap</code> in an <a href="methods.md#api_nan_set_accessor">accessor</a> should not use <code>Holder()</code> if the accessor is defined on the prototype.
So either define your accessors on the instance template,
or use <code>This()</code> after verifying that it is indeed a valid object.</p>

<h3>Examples</h3>

<h4>Basic</h4>

<p>```c++
class MyObject : public Nan::ObjectWrap {
 public:
  static NAN_MODULE_INIT(Init) {
    v8::Local<v8::functiontemplate> tpl = Nan::New<v8::functiontemplate>(New);
    tpl->SetClassName(Nan::New("MyObject").ToLocalChecked());
    tpl->InstanceTemplate()->SetInternalFieldCount(1);</v8::functiontemplate></v8::functiontemplate></p>

<pre><code>Nan::SetPrototypeMethod(tpl, "getHandle", GetHandle);
Nan::SetPrototypeMethod(tpl, "getValue", GetValue);

constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());
Nan::Set(target, Nan::New("MyObject").ToLocalChecked(),
  Nan::GetFunction(tpl).ToLocalChecked());   }
</code></pre>

<p>private:
  explicit MyObject(double value = 0) : value_(value) {}
  ~MyObject() {}</p>

<p>static NAN_METHOD(New) {
    if (info.IsConstructCall()) {
      double value = info[0]->IsUndefined() ? 0 : Nan::To<double>(info[0]).FromJust();
      MyObject *obj = new MyObject(value);
      obj->Wrap(info.This());
      info.GetReturnValue().Set(info.This());
    } else {
      const int argc = 1;
      v8::Local<v8::value> argv[argc] = {info[0]};
      v8::Local<v8::function> cons = Nan::New(constructor());
      info.GetReturnValue().Set(cons->NewInstance(argc, argv));
    }
  }</v8::function></v8::value></double></p>

<p>static NAN_METHOD(GetHandle) {
    MyObject* obj = Nan::ObjectWrap::Unwrap<myobject>(info.Holder());
    info.GetReturnValue().Set(obj->handle());
  }</myobject></p>

<p>static NAN_METHOD(GetValue) {
    MyObject* obj = Nan::ObjectWrap::Unwrap<myobject>(info.Holder());
    info.GetReturnValue().Set(obj->value_);
  }</myobject></p>

<p>static inline Nan::Persistent<v8::function> & constructor() {
    static Nan::Persistent<v8::function> my_constructor;
    return my_constructor;
  }</v8::function></v8::function></p>

<p>double value_;
};</p>

<p>NODE_MODULE(objectwrapper, MyObject::Init)
```</p>

<p>To use in Javascript:</p>

<p>```Javascript
var objectwrapper = require(‘bindings’)(‘objectwrapper’);</p>

<p>var obj = new objectwrapper.MyObject(5);
console.log(‘Should be 5: ‘ + obj.getValue());
```</p>

<h4>Factory of wrapped objects</h4>

<p>```c++
class MyFactoryObject : public Nan::ObjectWrap {
 public:
  static NAN_MODULE_INIT(Init) {
    v8::Local<v8::functiontemplate> tpl = Nan::New<v8::functiontemplate>(New);
    tpl->InstanceTemplate()->SetInternalFieldCount(1);</v8::functiontemplate></v8::functiontemplate></p>

<pre><code>Nan::SetPrototypeMethod(tpl, "getValue", GetValue);

constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());   }
</code></pre>

<p>static NAN_METHOD(NewInstance) {
    v8::Local<v8::function> cons = Nan::New(constructor());
    double value = info[0]->IsNumber() ? Nan::To<double>(info[0]).FromJust() : 0;
    const int argc = 1;
    v8::Local<v8::value> argv[1] = {Nan::New(value)};
    info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());
  }</v8::value></double></v8::function></p>

<p>// Needed for the next example:
  inline double value() const {
    return value_;
  }</p>

<p>private:
  explicit MyFactoryObject(double value = 0) : value_(value) {}
  ~MyFactoryObject() {}</p>

<p>static NAN_METHOD(New) {
    if (info.IsConstructCall()) {
      double value = info[0]->IsNumber() ? Nan::To<double>(info[0]).FromJust() : 0;
      MyFactoryObject * obj = new MyFactoryObject(value);
      obj->Wrap(info.This());
      info.GetReturnValue().Set(info.This());
    } else {
      const int argc = 1;
      v8::Local<v8::value> argv[argc] = {info[0]};
      v8::Local<v8::function> cons = Nan::New(constructor());
      info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());
    }
  }</v8::function></v8::value></double></p>

<p>static NAN_METHOD(GetValue) {
    MyFactoryObject* obj = ObjectWrap::Unwrap<myfactoryobject>(info.Holder());
    info.GetReturnValue().Set(obj->value_);
  }</myfactoryobject></p>

<p>static inline Nan::Persistent<v8::function> & constructor() {
    static Nan::Persistent<v8::function> my_constructor;
    return my_constructor;
  }</v8::function></v8::function></p>

<p>double value_;
};</p>

<p>NAN_MODULE_INIT(Init) {
  MyFactoryObject::Init(target);
  Nan::Set(target,
    Nan::New<v8::string>("newFactoryObjectInstance").ToLocalChecked(),
    Nan::GetFunction(
      Nan::New<v8::functiontemplate>(MyFactoryObject::NewInstance)).ToLocalChecked()
  );
}</v8::functiontemplate></v8::string></p>

<p>NODE_MODULE(wrappedobjectfactory, Init)
```</p>

<p>To use in Javascript:</p>

<p>```Javascript
var wrappedobjectfactory = require(‘bindings’)(‘wrappedobjectfactory’);</p>

<p>var obj = wrappedobjectfactory.newFactoryObjectInstance(10);
console.log(‘Should be 10: ‘ + obj.getValue());
```</p>

<h4>Passing wrapped objects around</h4>

<p>Use the <code>MyFactoryObject</code> class above along with the following:</p>

<p>```c++
static NAN_METHOD(Sum) {
  Nan::MaybeLocal<v8::object> maybe1 = Nan::To<v8::object>(info[0]);
  Nan::MaybeLocal<v8::object> maybe2 = Nan::To<v8::object>(info[1]);</v8::object></v8::object></v8::object></v8::object></p>

<p>// Quick check:
  if (maybe1.IsEmpty() || maybe2.IsEmpty()) {
    // return value is undefined by default
    return;
  }</p>

<p>MyFactoryObject* obj1 =
    Nan::ObjectWrap::Unwrap<myfactoryobject>(maybe1.ToLocalChecked());
  MyFactoryObject* obj2 =
    Nan::ObjectWrap::Unwrap<myfactoryobject>(maybe2.ToLocalChecked());</myfactoryobject></myfactoryobject></p>

<p>info.GetReturnValue().Set(Nan::New<v8::number>(obj1->value() + obj2->value()));
}</v8::number></p>

<p>NAN_MODULE_INIT(Init) {
  MyFactoryObject::Init(target);
  Nan::Set(target,
    Nan::New<v8::string>("newFactoryObjectInstance").ToLocalChecked(),
    Nan::GetFunction(
      Nan::New<v8::functiontemplate>(MyFactoryObject::NewInstance)).ToLocalChecked()
  );
  Nan::Set(target,
    Nan::New<v8::string>("sum").ToLocalChecked(),
    Nan::GetFunction(Nan::New<v8::functiontemplate>(Sum)).ToLocalChecked()
  );
}</v8::functiontemplate></v8::string></v8::functiontemplate></v8::string></p>

<p>NODE_MODULE(myaddon, Init)
```</p>

<p>To use in Javascript:</p>

<p>```Javascript
var myaddon = require(‘bindings’)(‘myaddon’);</p>

<p>var obj1 = myaddon.newFactoryObjectInstance(5);
var obj2 = myaddon.newFactoryObjectInstance(10);
console.log(‘sum of object values: ‘ + myaddon.sum(obj1, obj2));
```</p>