<h1>eslint-plugin-promise</h1>

<p>Enforce best practices for JavaScript promises.</p>

<p><a href="https://github.com/feross/standard"><img src="https://cdn.rawgit.com/feross/standard/master/badge.svg" alt="js-standard-style" /></a>
 <a href="https://travis-ci.org/xjamundx/eslint-plugin-promise"><img src="https://travis-ci.org/xjamundx/eslint-plugin-promise.svg" alt="travis-ci" /></a>
<a href="https://www.npmjs.com/package/eslint-plugin-promise"><img src="https://badge.fury.io/js/eslint-plugin-promise.svg" alt="npm version" /></a></p>

<h2>Installation</h2>

<p>You’ll first need to install <a href="http://eslint.org">ESLint</a>:</p>

<p><code>
$ npm i eslint --save-dev
</code></p>

<p>Next, install <code>eslint-plugin-promise</code>:</p>

<p><code>
$ npm install eslint-plugin-promise --save-dev
</code></p>

<p><strong>Note:</strong> If you installed ESLint globally (using the <code>-g</code> flag) then you must also install <code>eslint-plugin-promise</code> globally.</p>

<h2>Usage</h2>

<p>Add <code>promise</code> to the plugins section of your <code>.eslintrc</code> configuration file. You can omit the <code>eslint-plugin-</code> prefix:</p>

<p><code>json
{
    "plugins": [
        "promise"
    ]
}
</code></p>

<p>Then configure the rules you want to use under the rules section.</p>

<p><code>json
{
    "rules": {
        "promise/always-return": "error",
        "promise/no-return-wrap": "error",
        "promise/param-names": "error",
        "promise/catch-or-return": "error",
        "promise/no-native": "off",
        "promise/no-nesting": "warn",
        "promise/no-promise-in-callback": "warn",
        "promise/no-callback-in-promise": "warn",
        "promise/avoid-new": "warn",
        "promise/no-return-in-finally": "warn"
    }
}
</code></p>

<p>or start with the recommended rule set</p>

<p><code>json
{
    "extends": [
        "plugin:promise/recommended"
    ]
}
</code></p>

<h2>Rules</h2>

<h3>Promise Rules</h3>

<table>
  <thead>
    <tr>
      <th>recommended</th>
      <th>rule</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>:bangbang:</td>
      <td><code>catch-or-return</code></td>
      <td>Enforces the use of <code>catch()</code> on un-returned promises.</td>
    </tr>
    <tr>
      <td>:bangbang:</td>
      <td><code>no-return-wrap</code></td>
      <td>Avoid wrapping values in <code>Promise.resolve</code> or <code>Promise.reject</code> when not needed.</td>
    </tr>
    <tr>
      <td>:bangbang:</td>
      <td><code>param-names</code></td>
      <td>Enforce consistent param names when creating new promises.</td>
    </tr>
    <tr>
      <td>:bangbang:</td>
      <td><code>always-return</code></td>
      <td>Return inside each <code>then()</code> to create readable and reusable Promise chains.</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>no-native</code></td>
      <td>In an ES5 environment, make sure to create a <code>Promise</code> constructor before using.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td><code>no-nesting</code></td>
      <td>Avoid nested <code>then()</code> or <code>catch()</code> statements</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td><code>no-promise-in-callback</code></td>
      <td>Avoid using promises inside of callbacks</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td><code>no-callback-in-promise</code></td>
      <td>Avoid calling <code>cb()</code> inside of a <code>then()</code> (use <a href="https://www.npmjs.com/package/nodeify">nodeify</a> instead)</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td><code>avoid-new</code></td>
      <td>Avoid creating <code>new</code> promises outside of utility libs (use <a href="https://www.npmjs.com/package/pify">pify</a> instead)</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td><code>no-return-in-finally</code></td>
      <td>Disallow return statements in <code>finally()</code></td>
    </tr>
    <tr>
      <td>:seven:</td>
      <td><code>prefer-await-to-then</code></td>
      <td>Prefer <code>await</code> to <code>then()</code> for reading Promise values</td>
    </tr>
    <tr>
      <td>:seven:</td>
      <td><code>prefer-await-to-callbacks</code></td>
      <td>Prefer async/await to the callback pattern</td>
    </tr>
  </tbody>
</table>

<p><strong>Key</strong></p>

<table>
  <thead>
    <tr>
      <th>icon</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>:bangbang:</td>
      <td>Reports as error in recommended configuration</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td>Reports as warning in recommended configuration</td>
    </tr>
    <tr>
      <td>:seven:</td>
      <td>ES2017 Async Await rules</td>
    </tr>
  </tbody>
</table>

<h3>Rule: <code>catch-or-return</code></h3>

<p>Ensure that each time a <code>then()</code> is applied to a promise, a
<code>catch()</code> is applied as well. Exceptions are made if you are
returning that promise.</p>

<h4>Valid</h4>

<p><code>js
myPromise.then(doSomething).catch(errors);
myPromise.then(doSomething).then(doSomethingElse).catch(errors);
function doSomethingElse() { return myPromise.then(doSomething) }
</code></p>

<h4>Invalid</h4>

<p><code>js
myPromise.then(doSomething);
myPromise.then(doSomething, catchErrors); // catch() may be a little better
function doSomethingElse() { myPromise.then(doSomething) }
</code></p>

<h4>Options</h4>

<h4><code>allowThen</code></h4>

<p>You can pass an <code>{ allowThen: true }</code> as an option to this rule
 to allow for <code>.then(null, fn)</code> to be used instead of <code>catch()</code> at
 the end of the promise chain.</p>

<h4><code>terminationMethod</code></h4>

<p>You can pass a <code>{ terminationMethod: 'done' }</code> as an option to this rule
 to require <code>done()</code> instead of <code>catch()</code> at the end of the promise chain.
 This is useful for many non-standard Promise implementations.</p>

<p>You can also pass an array of methods such as
 <code>{ terminationMethod: ['catch',  'asCallback', 'finally'] }</code>.</p>

<p>This will allow any of
<code>js
Promise.resolve(1).then(() => { throw new Error('oops') }).catch(logerror)
Promise.resolve(1).then(() => { throw new Error('oops') }).asCallback(cb)
Promise.resolve(1).then(() => { throw new Error('oops') }).finally(cleanUp)
</code></p>

<h3>Rule: <code>always-return</code></h3>

<p>Ensure that inside a <code>then()</code> you make sure to <code>return</code> a new promise or value.
See http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html (rule #5)
for more info on why that’s a good idea.</p>

<p>We also allow someone to <code>throw</code> inside a <code>then()</code> which is essentially the same as <code>return Promise.reject()</code>.</p>

<h4>Valid</h4>

<p><code>js
myPromise.then((val) => val * 2));
myPromise.then(function(val) { return val * 2; });
myPromise.then(doSomething); // could be either
myPromise.then((b) => { if (b) { return "yes" } else { return "no" } });
</code></p>

<h4>Invalid</h4>

<p><code>js
myPromise.then(function(val) {});
myPromise.then(() => { doSomething(); });
myPromise.then((b) => { if (b) { return "yes" } else { forgotToReturn(); } });
</code></p>

<h3><code>param-names</code></h3>

<p>Enforce standard parameter names for Promise constructors</p>

<h4>Valid</h4>
<p><code>js
new Promise(function (resolve) { ... })
new Promise(function (resolve, reject) { ... })
</code></p>

<h4>Invalid</h4>
<p><code>js
new Promise(function (reject, resolve) { ... }) // incorrect order
new Promise(function (ok, fail) { ... }) // non-standard parameter names
</code></p>

<p>Ensures that <code>new Promise()</code> is instantiated with the parameter names <code>resolve, reject</code> to avoid confusion with order such as <code>reject, resolve</code>. The Promise constructor uses the <a href="https://blog.domenic.me/the-revealing-constructor-pattern/">RevealingConstructor pattern</a>. Using the same parameter names as the language specification makes code more uniform and easier to understand.</p>

<h3><code>no-native</code></h3>

<p>Ensure that <code>Promise</code> is included fresh in each file instead of relying
 on the existence of a native promise implementation. Helpful if you want
 to use <code>bluebird</code> or if you don’t intend to use an ES6 Promise shim.</p>

<h4>Valid</h4>
<p><code>js
var Promise = require("bluebird");
var x = Promise.resolve("good");
</code></p>

<h4>Invalid</h4>
<p><code>js
var x = Promise.resolve("bad");
</code></p>

<h3>Rule: <code>no-return-wrap</code></h3>

<p>Ensure that inside a <code>then()</code> or a <code>catch()</code> we always <code>return</code>
 or <code>throw</code> a raw value instead of wrapping in <code>Promise.resolve</code>
 or <code>Promise.reject</code></p>

<h4>Valid</h4>
<p><code>js
myPromise.then(function(val) {
  return val * 2;
});
myPromise.then(function(val) {
  throw "bad thing";
});
</code></p>

<h4>Invalid</h4>
<p><code>js
myPromise.then(function(val) {
  return Promise.resolve(val * 2);
});
myPromise.then(function(val) {
  return Promise.reject("bad thing");
})
</code></p>

<h4>Options</h4>

<h4><code>allowReject</code></h4>

<p>Pass <code>{ allowReject: true }</code> as an option to this rule to permit wrapping returned values with <code>Promise.reject</code>, such as when you would use it as another way to reject the promise.</p>

<h3>Rule: <code>no-return-in-finally</code></h3>

<p>Disallow return statements inside a callback passed to <code>finally()</code>, since nothing would consume what’s returned.</p>

<h4>Valid</h4>
<p><code>js
myPromise.finally(function(val) {
  console.log('value:', val);
});
</code></p>

<h4>Invalid</h4>
<p><code>js
myPromise.finally(function(val) {
  return val;
})
</code></p>

<h2>Etc</h2>

<ul>
  <li>(c) MMXV jden <a href="mailto:jason@denizac.org">jason@denizac.org</a> - ISC license.</li>
  <li>(c) 2016 Jamund Ferguson <a href="mailto:jamund@gmail.com">jamund@gmail.com</a> - ISC license.</li>
</ul>