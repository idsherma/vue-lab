<h1>run-queue</h1>

<p>A promise based, dynamic priority queue runner, with concurrency limiting.</p>

<p>```js
const RunQueue = require(‘run-queue’)</p>

<p>const queue = new RunQueue({
  maxConcurrency: 1
})</p>

<p>queue.add(1, example, [-1])
for (let ii = 0; ii < 5; ++ii) {
  queue.add(0, example, [ii])
}
const finished = []
queue.run().then(
  console.log(finished)
})</p>

<p>function example (num, next) {
  setTimeout(() => {
    finished.push(num)
    next()
  }, 5 - Math.abs(num))
}
```</p>

<p>would output</p>

<p><code>
[ 0, 1, 2, 3, 4, -1 ]
</code></p>

<p>If you bump concurrency to <code>2</code>, then you get:</p>

<p><code>
[ 1, 0, 3, 2, 4, -1 ]
</code></p>

<p>The concurrency means that they don’t finish in order, because some take
longer than others.  Each priority level must finish entirely before the
next priority level is run.  See
<a href="https://github.com/iarna/run-queue#priorities">PRIORITIES</a> below.  This is
even true if concurrency is set high enough that all of the regular queue
can execute at once, for instance, with <code>maxConcurrency: 10</code>:</p>

<p><code>
[ 4, 3, 2, 1, 0, -1 ]
</code></p>

<h2>API</h2>

<h3>const queue = new RunQueue(options)</h3>

<p>Create a new queue. Options may contain:</p>

<ul>
  <li>maxConcurrency - (Default: <code>1</code>) The maximum number of jobs to execute at once.</li>
  <li>Promise - (Default: global.Promise) The promise implementation to use.</li>
</ul>

<h3>queue.add (prio, fn, args)</h3>

<p>Add a new job to the end of the queue at priority <code>prio</code> that will run <code>fn</code>
with <code>args</code>. If <code>fn</code> is async then it should return a Promise.</p>

<h3>queue.run ()</h3>

<p>Start running the job queue.  Returns a Promise that resolves when either
all the jobs are complete or a job ends in error (throws or returns a
rejected promise). If a job ended in error then this Promise will be rejected
with that error and no further queue running will be done.</p>

<h2>PRIORITIES</h2>

<p>Priorities are any integer value >= 0.</p>

<p>Lowest is executed first.</p>

<p>Priorities essentially represent distinct job queues.  All jobs in a queue
must complete before the next highest priority job queue is executed.</p>

<p>This means that if you have two queues, <code>0</code> and <code>1</code> then ALL jobs in <code>0</code>
must complete before ANY execute in <code>1</code>.  If you add new <code>0</code> level jobs
while <code>1</code> level jobs are running then it will switch back processing the <code>0</code>
queue and won’t execute any more <code>1</code> jobs till all of the new <code>0</code> jobs
complete.</p>