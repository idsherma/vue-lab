<h1>babel-plugin-transform-es2015-for-of</h1>

<blockquote>
  <p>Compile ES2015 for…of to ES5</p>
</blockquote>

<h2>Example</h2>

<p><strong>In</strong></p>

<p><code>js
for (var i of foo) {}
</code></p>

<p><strong>Out</strong></p>

<p>```js
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;</p>

<p>try {
  for (var _iterator = foo<a href="">Symbol.iterator</a>, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var i = _step.value;
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}
```</p>

<h2>Installation</h2>

<p><code>sh
npm install --save-dev babel-plugin-transform-es2015-for-of
</code></p>

<h2>Usage</h2>

<h3>Via <code>.babelrc</code> (Recommended)</h3>

<p><strong>.babelrc</strong></p>

<p>```js
// without options
{
  “plugins”: [“transform-es2015-for-of”]
}</p>

<p>// with options
{
  “plugins”: [
    [“transform-es2015-for-of”, {
      “loose”: true
    }]
  ]
}
```</p>

<h3>Via CLI</h3>

<p><code>sh
babel --plugins transform-es2015-for-of script.js
</code></p>

<h3>Via Node API</h3>

<p><code>javascript
require("babel-core").transform("code", {
  plugins: ["transform-es2015-for-of"]
});
</code></p>

<h2>Options</h2>

<h3><code>loose</code></h3>

<p><code>boolean</code>, defaults to <code>false</code></p>

<p>In loose mode, arrays are put in a fast path, thus heavily increasing performance.
All other iterables will continue to work fine.</p>

<h4>Example</h4>

<p><strong>In</strong></p>

<p><code>js
for (var i of foo) {}
</code></p>

<p><strong>Out</strong></p>

<p>```js
for (var _iterator = foo, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator<a href="">Symbol.iterator</a>;;) {
  var _ref;</p>

<p>if (_isArray) {
    if (_i >= _iterator.length) break;
    _ref = _iterator[_i++];
  } else {
    _i = _iterator.next();
    if (_i.done) break;
    _ref = _i.value;
  }</p>

<p>var i = _ref;
}
```</p>

<h4>Abrupt completions</h4>

<p>In loose mode an iterator’s <code>return</code> method will not be called on abrupt completions caused by thrown errors.</p>

<p>Please see <a href="https://github.com/google/traceur-compiler/issues/1773">google/traceur-compiler#1773</a> and
<a href="https://github.com/babel/babel/issues/838">babel/babel#838</a> for more information.</p>

<h3>Optimization</h3>

<p>If a basic array is used, Babel will compile the for-of loop down to a regular for loop.</p>

<p><strong>In</strong></p>

<p><code>js
for (let a of [1,2,3]) {}
</code></p>

<p><strong>Out</strong></p>

<p><code>js
var _arr = [1, 2, 3];
for (var _i = 0; _i < _arr.length; _i++) {
  var a = _arr[_i];
}
</code></p>