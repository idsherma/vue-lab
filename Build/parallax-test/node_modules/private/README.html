<h1>private <a href="https://travis-ci.org/benjamn/private"><img src="https://travis-ci.org/benjamn/private.png?branch=master" alt="Build Status" /></a> <a href="https://greenkeeper.io/"><img src="https://badges.greenkeeper.io/benjamn/private.svg" alt="Greenkeeper badge" /></a></h1>

<p>A general-purpose utility for associating truly private state with any JavaScript object.</p>

<h2>Installation</h2>

<p>From NPM:</p>

<pre><code>npm install private
</code></pre>

<p>From GitHub:</p>

<pre><code>cd path/to/node_modules
git clone git://github.com/benjamn/private.git
cd private
npm install .
</code></pre>

<h2>Usage</h2>
<p><strong>Get or create a secret object associated with any (non-frozen) object:</strong>
```js
var getSecret = require(“private”).makeAccessor();
var obj = Object.create(null); // any kind of object works
getSecret(obj).totallySafeProperty = “p455w0rd”;</p>

<p>console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
console.log(getSecret(obj)); // { totallySafeProperty: “p455w0rd” }
```
Now, only code that has a reference to both <code>getSecret</code> and <code>obj</code> can possibly access <code>.totallySafeProperty</code>.</p>

<p><em>Importantly, no global references to the secret object are retained by the <code>private</code> package, so as soon as <code>obj</code> gets garbage collected, the secret will be reclaimed as well. In other words, you don’t have to worry about memory leaks.</em></p>

<p><strong>Create a unique property name that cannot be enumerated or guessed:</strong>
```js
var secretKey = require(“private”).makeUniqueKey();
var obj = Object.create(null); // any kind of object works</p>

<p>Object.defineProperty(obj, secretKey, {
  value: { totallySafeProperty: “p455w0rd” },
  enumerable: false // optional; non-enumerability is the default
});</p>

<p>Object.defineProperty(obj, “nonEnumerableProperty”, {
  value: “anyone can guess my name”,
  enumerable: false
});</p>

<p>console.log(obj[secretKey].totallySafeProperty); // p455w0rd
console.log(obj.nonEnumerableProperty); // “anyone can guess my name”
console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // [“nonEnumerableProperty”]</p>

<p>for (var key in obj) {
  console.log(key); // never called
}
```
Because these keys are non-enumerable, you can’t discover them using a <code>for</code>-<code>in</code> loop. Because <code>secretKey</code> is a long string of random characters, you would have a lot of trouble guessing it. And because the <code>private</code> module wraps <code>Object.getOwnPropertyNames</code> to exclude the keys it generates, you can’t even use that interface to discover it.</p>

<p>Unless you have access to the value of the <code>secretKey</code> property name, there is no way to access the value associated with it. So your only responsibility as secret-keeper is to avoid handing out the value of <code>secretKey</code> to untrusted code.</p>

<p>Think of this style as a home-grown version of the first style. Note, however, that it requires a full implementation of ES5’s <code>Object.defineProperty</code> method in order to make any safety guarantees, whereas the first example will provide safety even in environments that do not support <code>Object.defineProperty</code>.</p>

<h2>Rationale</h2>

<p>In JavaScript, the only data that are truly private are local variables
whose values do not <em>leak</em> from the scope in which they were defined.</p>

<p>This notion of <em>closure privacy</em> is powerful, and it readily provides some
of the benefits of traditional data privacy, a la Java or C++:
```js
function MyClass(secret) {
    this.increment = function() {
        return ++secret;
    };
}</p>

<p>var mc = new MyClass(3);
console.log(mc.increment()); // 4
```
You can learn something about <code>secret</code> by calling <code>.increment()</code>, and you
can increase its value by one as many times as you like, but you can never
decrease its value, because it is completely inaccessible except through
the <code>.increment</code> method. And if the <code>.increment</code> method were not
available, it would be as if no <code>secret</code> variable had ever been declared,
as far as you could tell.</p>

<p>This style breaks down as soon as you want to inherit methods from the
prototype of a class:
```js
function MyClass(secret) {
    this.secret = secret;
}</p>

<p>MyClass.prototype.increment = function() {
    return ++this.secret;
};
<code>
The only way to communicate between the `MyClass` constructor and the
`.increment` method in this example is to manipulate shared properties of
`this`. Unfortunately `this.secret` is now exposed to unlicensed
modification:
</code>js
var mc = new MyClass(6);
console.log(mc.increment()); // 7
mc.secret -= Infinity;
console.log(mc.increment()); // -Infinity
mc.secret = “Go home JavaScript, you’re drunk.”;
mc.increment(); // NaN
```
Another problem with closure privacy is that it only lends itself to
per-instance privacy, whereas the <code>private</code> keyword in most
object-oriented languages indicates that the data member in question is
visible to all instances of the same class.</p>

<p>Suppose you have a <code>Node</code> class with a notion of parents and children:
```js
function Node() {
    var parent;
    var children = [];</p>

<pre><code>this.getParent = function() {
    return parent;
};

this.appendChild = function(child) {
    children.push(child);
    child.parent = this; // Can this be made to work?
}; } ``` The desire here is to allow other `Node` objects to manipulate the value returned by `.getParent()`, but otherwise disallow any modification of the `parent` variable. You could expose a `.setParent` function, but then anyone could call it, and you might as well give up on the getter/setter pattern.
</code></pre>

<p>This module solves both of these problems.</p>

<h2>Usage</h2>

<p>Let’s revisit the <code>Node</code> example from above:
```js
var p = require(“private”).makeAccessor();</p>

<p>function Node() {
    var privates = p(this);
    var children = [];</p>

<pre><code>this.getParent = function() {
    return privates.parent;
};

this.appendChild = function(child) {
    children.push(child);
    var cp = p(child);
    if (cp.parent)
        cp.parent.removeChild(child);
    cp.parent = this;
    return child;
}; } ``` Now, in order to access the private data of a `Node` object, you need to have access to the unique `p` function that is being used here.  This is already an improvement over the previous example, because it allows restricted access by other `Node` instances, but can it help with the `Node.prototype` problem too?
</code></pre>

<p>Yes it can!
```js
var p = require(“private”).makeAccessor();</p>

<p>function Node() {
    p(this).children = [];
}</p>

<p>var Np = Node.prototype;</p>

<p>Np.getParent = function() {
    return p(this).parent;
};</p>

<p>Np.appendChild = function(child) {
    p(this).children.push(child);
    var cp = p(child);
    if (cp.parent)
        cp.parent.removeChild(child);
    cp.parent = this;
    return child;
};
```
Because <code>p</code> is in scope not only within the <code>Node</code> constructor but also
within <code>Node</code> methods, we can finally avoid redefining methods every time
the <code>Node</code> constructor is called.</p>

<p>Now, you might be wondering how you can restrict access to <code>p</code> so that no
untrusted code is able to call it. The answer is to use your favorite
module pattern, be it CommonJS, AMD <code>define</code>, or even the old
Immediately-Invoked Function Expression:
```js
var Node = (function() {
    var p = require(“private”).makeAccessor();</p>

<pre><code>function Node() {
    p(this).children = [];
}

var Np = Node.prototype;

Np.getParent = function() {
    return p(this).parent;
};

Np.appendChild = function(child) {
    p(this).children.push(child);
    var cp = p(child);
    if (cp.parent)
        cp.parent.removeChild(child);
    cp.parent = this;
    return child;
};

return Node; }());
</code></pre>

<p>var parent = new Node;
var child = new Node;
parent.appendChild(child);
assert.strictEqual(child.getParent(), parent);
```
Because this version of <code>p</code> never leaks from the enclosing function scope,
only <code>Node</code> objects have access to it.</p>

<p>So, you see, the claim I made at the beginning of this README remains
true:</p>

<blockquote>
  <p>In JavaScript, the only data that are truly private are local variables
whose values do not <em>leak</em> from the scope in which they were defined.</p>
</blockquote>

<p>It just so happens that closure privacy is sufficient to implement a
privacy model similar to that provided by other languages.</p>