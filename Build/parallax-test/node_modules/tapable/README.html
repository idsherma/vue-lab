<h1>Tapable</h1>

<p><code>javascript
var Tapable = require("tapable");
</code></p>

<p><code>Tapable</code> is a class for plugin binding and applying.</p>

<p>Just extend it.</p>

<p>``` javascript
function MyClass() {
	Tapable.call(this);
}</p>

<p>MyClass.prototype = Object.create(Tapable.prototype);</p>

<p>MyClass.prototype.method = function() {};
```</p>

<p>Or mix it in.</p>

<p>``` javascript
function MyClass2() {
	EventEmitter.call(this);
	Tapable.call(this);
}</p>

<p>MyClass2.prototype = Object.create(EventEmitter.prototype);
Tapable.mixin(MyClass2.prototype);</p>

<p>MyClass2.prototype.method = function() {};
```</p>

<h2>Public functions</h2>

<h3>apply</h3>

<p><code>javascript
void apply(plugins: Plugin...)
</code></p>

<p>Attaches all plugins passed as arguments to the instance, by calling <code>apply</code> on them.</p>

<h3>plugin</h3>

<p><code>javascript
void plugin(names: string|string[], handler: Function)
</code></p>

<p><code>names</code> are the names (or a single name) of the plugin interfaces the class provides.</p>

<p><code>handler</code> is a callback function. The signature depends on the class. <code>this</code> is the instance of the class.</p>

<h2>Protected functions</h2>

<h3>applyPlugins</h3>

<p><code>javascript
void applyPlugins(name: string, args: any...)
</code></p>

<p>Synchronously applies all registered handlers for <code>name</code>. The handler functions are called with all args.</p>

<h3>applyPluginsWaterfall</h3>

<p><code>javascript
any applyPluginsWaterfall(name: string, init: any, args: any...)
</code></p>

<p>Synchronously applies all registered handlers for <code>name</code>. The handler functions are called with the return value of the previous handler and all args. For the first handler <code>init</code> is used and the return value of the last handler is return by <code>applyPluginsWaterfall</code></p>

<h3>applyPluginsAsync</h3>

<p><code>javascript
void applyPluginsAsync(
	name: string,
	args: any...,
	callback: (err?: Error) -> void
)
</code></p>

<p>Asynchronously applies all registered handlers for <code>name</code>. The handler functions are called with all args and a callback function with the signature <code>(err?: Error) -> void</code>. The handler functions are called in order of registration.</p>

<p><code>callback</code> is called after all handlers are called.</p>

<h3>applyPluginsBailResult</h3>

<p><code>javascript
any applyPluginsBailResult(name: string, args: any...)
</code></p>

<p>Synchronously applies all registered handlers for <code>name</code>. The handler function are called with all args. If a handler function returns something <code>!== undefined</code>, the value is returned and no more handlers are applied.</p>

<h3>applyPluginsAsyncWaterfall</h3>

<p><code>javascript
applyPluginsAsyncWaterfall(
	name: string,
	init: any,
	callback: (err: Error, result: any) -> void
)
</code></p>

<p>Asynchronously applies all registered handlers for <code>name</code>. The handler functions are called with the current value and a callback function with the signature <code>(err: Error, nextValue: any) -> void</code>. When called, <code>nextValue</code> is the current value for the next handler. The current value for the first handler is <code>init</code>. After all handlers are applied, <code>callback</code> is called with the last value. If any handler passes a value for <code>err</code>, the <code>callback</code> is called with this error and no more handlers are called.</p>

<h3>applyPluginsAsyncSeries</h3>

<p><code>javascript
applyPluginsAsyncSeries(
	name: string,
	args: any...,
	callback: (err: Error, result: any) -> void
)
</code></p>

<p>Asynchronously applies all registered handlers for <code>name</code>. The handler functions are called with all <code>args</code> and a callback function with the signature <code>(err: Error) -> void</code>. The handlers are called in series, one at a time. After all handlers are applied, <code>callback</code> is called. If any handler passes a value for <code>err</code>, the <code>callback</code> is called with this error and no more handlers are called.</p>

<h3>applyPluginsParallel</h3>

<p><code>javascript
applyPluginsParallel(
	name: string,
	args: any...,
	callback: (err?: Error) -> void
)
</code></p>

<p>Applies all registered handlers for <code>name</code> in parallel. The handler functions are called with all args and a callback function with the signature <code>(err?: Error) -> void</code>. The <code>callback</code> function is called when all handlers have called the callback without <code>err</code>. If any handler calls the callback with <code>err</code>, <code>callback</code> is invoked with this error and the other handlers are ignored.</p>

<h3>applyPluginsParallelBailResult</h3>

<p><code>javascript
applyPluginsParallelBailResult(
	name: string,
	args: any...,
	callback: (err: Error, result: any) -> void
)
</code></p>

<p>Applies all registered handlers for <code>name</code> in parallel. The handler functions are called with all args and a callback function with the signature <code>(err?: Error) -> void</code>. Handler functions must call the callback. They can either pass an error, pass undefined, or pass a value. The first result (either error or value) which is not undefined is passed to the <code>callback</code>. The order is defined by registration, not by the speed of the handler function.</p>

<h3>hasPlugins</h3>

<p><code>js
hasPlugins(
	name: string
)
</code></p>

<p>Returns true, if plugins are registered for this name.</p>