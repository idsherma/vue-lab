<h1>Regenerate <a href="https://travis-ci.org/mathiasbynens/regenerate"><img src="https://travis-ci.org/mathiasbynens/regenerate.svg?branch=master" alt="Build status" /></a> <a href="https://codecov.io/gh/mathiasbynens/regenerate"><img src="https://img.shields.io/codecov/c/github/mathiasbynens/regenerate.svg" alt="Code coverage status" /></a> <a href="https://gemnasium.com/mathiasbynens/regenerate"><img src="https://gemnasium.com/mathiasbynens/regenerate.svg" alt="Dependency status" /></a></h1>

<p><em>Regenerate</em> is a Unicode-aware regex generator for JavaScript. It allows you to easily generate ES5-compatible regular expressions based on a given set of Unicode symbols or code points. (This is trickier than you might think, because of <a href="https://mathiasbynens.be/notes/javascript-unicode">how JavaScript deals with astral symbols</a>.)</p>

<h2>Installation</h2>

<p>Via <a href="https://npmjs.org/">npm</a>:</p>

<p><code>bash
npm install regenerate
</code></p>

<p>Via <a href="http://bower.io/">Bower</a>:</p>

<p><code>bash
bower install regenerate
</code></p>

<p>Via <a href="https://github.com/component/component">Component</a>:</p>

<p><code>bash
component install mathiasbynens/regenerate
</code></p>

<p>In a browser:</p>

<p><code>html
<script src="regenerate.js"></script>
</code></p>

<p>In <a href="https://nodejs.org/">Node.js</a>, <a href="https://iojs.org/">io.js</a>, and <a href="http://ringojs.org/">RingoJS ≥ v0.8.0</a>:</p>

<p><code>js
var regenerate = require('regenerate');
</code></p>

<p>In <a href="http://narwhaljs.org/">Narwhal</a> and <a href="http://ringojs.org/">RingoJS ≤ v0.7.0</a>:</p>

<p><code>js
var regenerate = require('regenerate').regenerate;
</code></p>

<p>In <a href="http://www.mozilla.org/rhino/">Rhino</a>:</p>

<p><code>js
load('regenerate.js');
</code></p>

<p>Using an AMD loader like <a href="http://requirejs.org/">RequireJS</a>:</p>

<p><code>js
require(
  {
    'paths': {
      'regenerate': 'path/to/regenerate'
    }
  },
  ['regenerate'],
  function(regenerate) {
    console.log(regenerate);
  }
);
</code></p>

<h2>API</h2>

<h3><code>regenerate(value1, value2, value3, ...)</code></h3>

<p>The main Regenerate function. Calling this function creates a new set that gets a chainable API.</p>

<p><code>js
var set = regenerate()
  .addRange(0x60, 0x69) // add U+0060 to U+0069
  .remove(0x62, 0x64) // remove U+0062 and U+0064
  .add(0x1D306); // add U+1D306
set.valueOf();
// → [0x60, 0x61, 0x63, 0x65, 0x66, 0x67, 0x68, 0x69, 0x1D306]
set.toString();
// → '[`ace-i]|\\uD834\\uDF06'
set.toRegExp();
// → /[`ace-i]|\uD834\uDF06/
</code></p>

<p>Any arguments passed to <code>regenerate()</code> will be added to the set right away. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.</p>

<p>```js
regenerate(0x1D306, ‘A’, ‘©’, 0x2603).toString();
// → ‘[A\xA9\u2603]|\uD834\uDF06’</p>

<p>var items = [0x1D306, ‘A’, ‘©’, 0x2603];
regenerate(items).toString();
// → ‘[A\xA9\u2603]|\uD834\uDF06’
```</p>

<h3><code>regenerate.prototype.add(value1, value2, value3, ...)</code></h3>

<p>Any arguments passed to <code>add()</code> are added to the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.</p>

<p>```js
regenerate().add(0x1D306, ‘A’, ‘©’, 0x2603).toString();
// → ‘[A\xA9\u2603]|\uD834\uDF06’</p>

<p>var items = [0x1D306, ‘A’, ‘©’, 0x2603];
regenerate().add(items).toString();
// → ‘[A\xA9\u2603]|\uD834\uDF06’
```</p>

<p>It’s also possible to pass in a Regenerate instance. Doing so adds all code points in that instance to the current set.</p>

<p><code>js
var set = regenerate(0x1D306, 'A');
regenerate().add('©', 0x2603).add(set).toString();
// → '[A\\xA9\\u2603]|\\uD834\\uDF06'
</code></p>

<p>Note that the initial call to <code>regenerate()</code> acts like <code>add()</code>. This allows you to create a new Regenerate instance and add some code points to it in one go:</p>

<p><code>js
regenerate(0x1D306, 'A', '©', 0x2603).toString();
// → '[A\\xA9\\u2603]|\\uD834\\uDF06'
</code></p>

<h3><code>regenerate.prototype.remove(value1, value2, value3, ...)</code></h3>

<p>Any arguments passed to <code>remove()</code> are removed to the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.</p>

<p><code>js
regenerate(0x1D306, 'A', '©', 0x2603).remove('☃').toString();
// → '[A\\xA9]|\\uD834\\uDF06'
</code></p>

<p>It’s also possible to pass in a Regenerate instance. Doing so removes all code points in that instance from the current set.</p>

<p><code>js
var set = regenerate('☃');
regenerate(0x1D306, 'A', '©', 0x2603).remove(set).toString();
// → '[A\\xA9]|\\uD834\\uDF06'
</code></p>

<h3><code>regenerate.prototype.addRange(start, end)</code></h3>

<p>Adds a range of code points from <code>start</code> to <code>end</code> (inclusive) to the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted.</p>

<p>```js
regenerate(0x1D306).addRange(0x00, 0xFF).toString(16);
// → ‘[\0-\xFF]|\uD834\uDF06’</p>

<p>regenerate().addRange(‘A’, ‘z’).toString();
// → ‘[A-z]’
```</p>

<h3><code>regenerate.prototype.removeRange(start, end)</code></h3>

<p>Removes a range of code points from <code>start</code> to <code>end</code> (inclusive) from the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted.</p>

<p>```js
regenerate()
  .addRange(0x000000, 0x10FFFF) // add all Unicode code points
  .removeRange(‘A’, ‘z’) // remove all symbols from <code>A</code> to <code>z</code>
  .toString();
// → ‘[\0-@\{-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|<a href="?![\\uDC00-\\uDFFF]">\uD800-\uDBFF</a>|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]’</p>

<p>regenerate()
  .addRange(0x000000, 0x10FFFF) // add all Unicode code points
  .removeRange(0x0041, 0x007A) // remove all code points from U+0041 to U+007A
  .toString();
// → ‘[\0-@\{-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|<a href="?![\\uDC00-\\uDFFF]">\uD800-\uDBFF</a>|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]’
```</p>

<h3><code>regenerate.prototype.intersection(codePoints)</code></h3>

<p>Removes any code points from the set that are not present in both the set and the given <code>codePoints</code> array. <code>codePoints</code> must be an array of numeric code point values, i.e. numbers.</p>

<p><code>js
regenerate()
  .addRange(0x00, 0xFF) // add extended ASCII code points
  .intersection([0x61, 0x69]) // remove all code points from the set except for these
  .toString();
// → '[ai]'
</code></p>

<p>Instead of the <code>codePoints</code> array, it’s also possible to pass in a Regenerate instance.</p>

<p>```js
var whitelist = regenerate(0x61, 0x69);</p>

<p>regenerate()
  .addRange(0x00, 0xFF) // add extended ASCII code points
  .intersection(whitelist) // remove all code points from the set except for those in the <code>whitelist</code> set
  .toString();
// → ‘[ai]’
```</p>

<h3><code>regenerate.prototype.contains(value)</code></h3>

<p>Returns <code>true</code> if the given value is part of the set, and <code>false</code> otherwise. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted.</p>

<p><code>js
var set = regenerate().addRange(0x00, 0xFF);
set.contains('A');
// → true
set.contains(0x1D306);
// → false
</code></p>

<h3><code>regenerate.prototype.clone()</code></h3>

<p>Returns a clone of the current code point set. Any actions performed on the clone won’t mutate the original set.</p>

<p><code>js
var setA = regenerate(0x1D306);
var setB = setA.clone().add(0x1F4A9);
setA.toArray();
// → [0x1D306]
setB.toArray();
// → [0x1D306, 0x1F4A9]
</code></p>

<h3><code>regenerate.prototype.toString(options)</code></h3>

<p>Returns a string representing (part of) a regular expression that matches all the symbols mapped to the code points within the set.</p>

<p><code>js
regenerate(0x1D306, 0x1F4A9).toString();
// → '\\uD834\\uDF06|\\uD83D\\uDCA9'
</code></p>

<p>If the <code>bmpOnly</code> property of the optional <code>options</code> object is set to <code>true</code>, the output matches surrogates individually, regardless of whether they’re lone surrogates or just part of a surrogate pair. This simplifies the output, but it can only be used in case you’re certain the strings it will be used on don’t contain any astral symbols.</p>

<p>```js
var highSurrogates = regenerate().addRange(0xD800, 0xDBFF);
highSurrogates.toString();
// → ‘<a href="?![\\uDC00-\\uDFFF]">\uD800-\uDBFF</a>’
highSurrogates.toString({ ‘bmpOnly’: true });
// → ‘[\uD800-\uDBFF]’</p>

<p>var lowSurrogates = regenerate().addRange(0xDC00, 0xDFFF);
lowSurrogates.toString();
// → ‘(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]’
lowSurrogates.toString({ ‘bmpOnly’: true });
// → ‘[\uDC00-\uDFFF]’
```</p>

<p>Note that lone low surrogates cannot be matched accurately using regular expressions in JavaScript. Regenerate’s output makes a best-effort approach but <a href="https://github.com/mathiasbynens/regenerate/issues/28#issuecomment-72224808">there can be false negatives in this regard</a>.</p>

<p>If the <code>hasUnicodeFlag</code> property of the optional <code>options</code> object is set to <code>true</code>, the output makes use of Unicode code point escapes (<code>\u{…}</code>) where applicable. This simplifies the output at the cost of compatibility and portability, since it means the output can only be used as a pattern in a regular expression with <a href="https://mathiasbynens.be/notes/es6-unicode-regex">the ES6 <code>u</code> flag</a> enabled.</p>

<p>```js
var set = regenerate().addRange(0x0, 0x10FFFF);</p>

<p>set.toString();
// → ‘[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|<a href="?![\\uDC00-\\uDFFF]">\uD800-\uDBFF</a>|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]’’</p>

<p>set.toString({ ‘hasUnicodeFlag’: true });
// → ‘[\0-\u{10FFFF}]’
```</p>

<h3><code>regenerate.prototype.toRegExp(flags = '')</code></h3>

<p>Returns a regular expression that matches all the symbols mapped to the code points within the set. Optionally, you can pass <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Parameters">flags</a> to be added to the regular expression.</p>

<p>```js
var regex = regenerate(0x1D306, 0x1F4A9).toRegExp();
// → /\uD834\uDF06|\uD83D\uDCA9/
regex.test(‘𝌆’);
// → true
regex.test(‘A’);
// → false</p>

<p>// With flags:
var regex = regenerate(0x1D306, 0x1F4A9).toRegExp(‘g’);
// → /\uD834\uDF06|\uD83D\uDCA9/g
```</p>

<p><strong>Note:</strong> This probably shouldn’t be used. Regenerate is intended as a tool that is used as part of a build process, not at runtime.</p>

<h3><code>regenerate.prototype.valueOf()</code> or <code>regenerate.prototype.toArray()</code></h3>

<p>Returns a sorted array of unique code points in the set.</p>

<p><code>js
regenerate(0x1D306)
  .addRange(0x60, 0x65)
  .add(0x59, 0x60) // note: 0x59 is added after 0x65, and 0x60 is a duplicate
  .valueOf();
// → [0x59, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x1D306]
</code></p>

<h3><code>regenerate.version</code></h3>

<p>A string representing the semantic version number.</p>

<h2>Combine Regenerate with other libraries</h2>

<p>Regenerate gets even better when combined with other libraries such as <a href="https://mths.be/punycode">Punycode.js</a>. Here’s an example where <a href="https://mths.be/punycode">Punycode.js</a> is used to convert a string into an array of code points, that is then passed on to Regenerate:</p>

<p>```js
var regenerate = require(‘regenerate’);
var punycode = require(‘punycode’);</p>

<p>var string = ‘Lorem ipsum dolor sit amet.’;
// Get an array of all code points used in the string:
var codePoints = punycode.ucs2.decode(string);</p>

<p>// Generate a regular expression that matches any of the symbols used in the string:
regenerate(codePoints).toString();
// → ‘[ \.Ladeilmopr-u]’
```</p>

<p>In ES6 you can do something similar with <a href="https://mths.be/array-from"><code>Array.from</code></a> which uses <a href="https://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols">the string’s iterator</a> to split the given string into an array of strings that each contain a single symbol. <a href="#regenerateprototypeaddvalue1-value2-value3-"><code>regenerate()</code></a> accepts both strings and code points, remember?</p>

<p>```js
var regenerate = require(‘regenerate’);</p>

<p>var string = ‘Lorem ipsum dolor sit amet.’;
// Get an array of all symbols used in the string:
var symbols = Array.from(string);</p>

<p>// Generate a regular expression that matches any of the symbols used in the string:
regenerate(symbols).toString();
// → ‘[ \.Ladeilmopr-u]’
```</p>

<h2>Support</h2>

<p>Regenerate supports at least Chrome 27+, Firefox 3+, Safari 4+, Opera 10+, IE 6+, Node.js v0.10.0+, io.js v1.0.0+, Narwhal 0.3.2+, RingoJS 0.8+, PhantomJS 1.9.0+, and Rhino 1.7RC4+.</p>

<h2>Unit tests & code coverage</h2>

<p>After cloning this repository, run <code>npm install</code> to install the dependencies needed for Regenerate development and testing. You may want to install Istanbul <em>globally</em> using <code>npm install istanbul -g</code>.</p>

<p>Once that’s done, you can run the unit tests in Node using <code>npm test</code> or <code>node tests/tests.js</code>. To run the tests in Rhino, Ringo, Narwhal, and web browsers as well, use <code>grunt test</code>.</p>

<p>To generate the code coverage report, use <code>grunt cover</code>.</p>

<h2>Author</h2>

<table>
  <thead>
    <tr>
      <th><a href="https://twitter.com/mathias" title="Follow @mathias on Twitter"><img src="https://gravatar.com/avatar/24e08a9ea84deb17ae121074d0f17125?s=70" alt="twitter/mathias" /></a></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://mathiasbynens.be/">Mathias Bynens</a></td>
    </tr>
  </tbody>
</table>

<h2>License</h2>

<p>Regenerate is available under the <a href="https://mths.be/mit">MIT</a> license.</p>