{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "/parallax-test/node_modules/pretty-error/test/ParsedError.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "chai = require 'chai'\nParsedError = require '../src/ParsedError'\n\nchai.should()\n\nerror = (what) ->\n  if typeof what is 'string'\n    return error -> throw Error what\n\n  else if what instanceof Function\n    try\n      do what\n      return null\n    catch e\n      return e\n\n  else\n    throw Error \"bad argument for error\"\n\ndescribe \"ParsedError\", ->\n  describe \"constructor()\", ->\n    it \"should accept Error() instances\", ->\n      (-> new ParsedError error -> throw Error \"some message\").should.not.throw()\n\n    it \"should accept ReferenceError() and other derivatives of Error()\", ->\n      (-> new ParsedError error -> throw ReferenceError \"some message\").should.not.throw()\n\n    it \"should accept non errors\", ->\n      (-> e = new ParsedError 'some string').should.not.throw()\n\n  describe \"message\", ->\n    it \"should return the original error message\", ->\n      e = new ParsedError error 'a'\n      e.message.should.equal 'a'\n\n  describe \"kind\", ->\n    it \"should return 'Error' for normal error\", ->\n      e = new ParsedError error 'a'\n      e.kind.should.equal 'Error'\n\n    it \"should recognize 'ReferenceError'\", ->\n      e = new ParsedError error -> a.b = c\n      e.kind.should.equal 'ReferenceError'\n\n  describe \"type\", ->\n    it.skip \"should return original error type\", ->\n      e = new ParsedError error -> a.b = c\n      e.type.should.be.equal 'not_defined'\n\n  describe \"arguments\", ->\n    it.skip \"should return original error arguments\", ->\n      e = new ParsedError error -> a.b = c\n      e.arguments.should.be.eql ['a']\n\n  describe \"stack\", ->\n    it \"should return original error stack\", ->\n      e = new ParsedError error -> a.b = c\n      e.stack.should.be.equal e.error.stack\n\n  describe \"trace\", ->\n    it \"should include correct information about each trace item\", ->\n      e = new ParsedError error -> a.b = c\n      e.trace.should.have.length.above 2\n\n      item = e.trace[0]\n      item.should.include.keys 'original',\n        'what', 'path', 'addr',\n        'file', 'dir', 'col',\n        'line', 'jsCol', 'jsLine'\n        'packageName', 'shortenedPath', 'shortenedAddr'\n\n      item.path.should.equal module.filename.replace(/[\\\\]+/g, '/')\n\n      item.line.should.be.a 'number'\n      item.col.should.be.a 'number'\n\n  describe \"_rectifyPath()\", ->\n    it \"should work\", ->\n      ParsedError::_rectifyPath('F:/a/node_modules/b/node_modules/d/node_modules/e/f.js').path.should.equal '[a]/[b]/[d]/[e]/f.js'\n\n    it \"should return path when `node_modules` is not present\", ->\n      ParsedError::_rectifyPath('a/b/c').path.should.equal 'a/b/c'\n"
  ]
}