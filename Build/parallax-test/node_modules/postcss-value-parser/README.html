<h1>postcss-value-parser</h1>

<p><a href="https://travis-ci.org/TrySound/postcss-value-parser"><img src="https://travis-ci.org/TrySound/postcss-value-parser.svg" alt="Travis CI" /></a></p>

<p>Transforms CSS declaration values and at-rule parameters into a tree of nodes, and provides a simple traversal API.</p>

<h2>Usage</h2>

<p><code>js
var valueParser = require('postcss-value-parser');
var cssBackgroundValue = 'url(foo.png) no-repeat 40px 73%';
var parsedValue = valueParser(cssBackgroundValue);
// parsedValue exposes an API described below,
// e.g. parsedValue.walk(..), parsedValue.toString(), etc.
</code></p>

<p>For example, parsing the value <code>rgba(233, 45, 66, .5)</code> will return the following:</p>

<p><code>js
{
  nodes: [
    {
      type: 'function',
      value: 'rgba',
      before: '',
      after: '',
      nodes: [
        { type: 'word', value: '233' },
        { type: 'div', value: ',', before: '', after: ' ' },
        { type: 'word', value: '45' },
        { type: 'div', value: ',', before: '', after: ' ' },
        { type: 'word', value: '66' },
        { type: 'div', value: ',', before: ' ', after: '' },
        { type: 'word', value: '.5' }
      ]
    }
  ]
}
</code></p>

<p>If you wanted to convert each <code>rgba()</code> value in <code>sourceCSS</code> to a hex value, you could do so like this:</p>

<p>```js
var valueParser = require(‘postcss-value-parser’);</p>

<p>var parsed = valueParser(sourceCSS);</p>

<p>// walk() will visit all the of the nodes in the tree,
// invoking the callback for each.
parsed.walk(function (node) {</p>

<p>// Since we only want to transform rgba() values,
  // we can ignore anything else.
  if (node.type !== ‘function’ && node.value !== ‘rgba’) return;</p>

<p>// We can make an array of the rgba() arguments to feed to a
  // convertToHex() function
  var color = node.nodes.filter(function (node) {
    return node.type === ‘word’;
  }).map(function (node) {
    return Number(node.value);
  }); // [233, 45, 66, .5]</p>

<p>// Now we will transform the existing rgba() function node
  // into a word node with the hex value
  node.type = ‘word’;
  node.value = convertToHex(color);
})</p>

<p>parsed.toString(); // #E92D42
```</p>

<h2>Nodes</h2>

<p>Each node is an object with these common properties:</p>

<ul>
  <li><strong>type</strong>: The type of node (<code>word</code>, <code>string</code>, <code>div</code>, <code>space</code>, <code>comment</code>, or <code>function</code>).
Each type is documented below.</li>
  <li><strong>value</strong>: Each node has a <code>value</code> property; but what exactly <code>value</code> means
is specific to the node type. Details are documented for each type below.</li>
  <li><strong>sourceIndex</strong>: The starting index of the node within the original source
string. For example, given the source string <code>10px 20px</code>, the <code>word</code> node
whose value is <code>20px</code> will have a <code>sourceIndex</code> of <code>5</code>.</li>
</ul>

<h3>word</h3>

<p>The catch-all node type that includes keywords (e.g. <code>no-repeat</code>),
quantities (e.g. <code>20px</code>, <code>75%</code>, <code>1.5</code>), and hex colors (e.g. <code>#e6e6e6</code>).</p>

<p>Node-specific properties:</p>

<ul>
  <li><strong>value</strong>: The “word” itself.</li>
</ul>

<h3>string</h3>

<p>A quoted string value, e.g. <code>"something"</code> in <code>content: "something";</code>.</p>

<p>Node-specific properties:</p>

<ul>
  <li><strong>value</strong>: The text content of the string.</li>
  <li><strong>quote</strong>: The quotation mark surrounding the string, either <code>"</code> or <code>'</code>.</li>
  <li><strong>unclosed</strong>: <code>true</code> if the string was not closed properly. e.g. <code>"unclosed string  </code>.</li>
</ul>

<h3>div</h3>

<p>A divider, for example</p>

<ul>
  <li><code>,</code> in <code>animation-duration: 1s, 2s, 3s</code></li>
  <li><code>/</code> in <code>border-radius: 10px / 23px</code></li>
  <li><code>:</code> in <code>(min-width: 700px)</code></li>
</ul>

<p>Node-specific properties:</p>

<ul>
  <li><strong>value</strong>: The divider character. Either <code>,</code>, <code>/</code>, or <code>:</code> (see examples above).</li>
  <li><strong>before</strong>: Whitespace before the divider.</li>
  <li><strong>after</strong>: Whitespace after the divider.</li>
</ul>

<h3>space</h3>

<p>Whitespace used as a separator, e.g. ` ` occurring twice in <code>border: 1px solid black;</code>.</p>

<p>Node-specific properties:</p>

<ul>
  <li><strong>value</strong>: The whitespace itself.</li>
</ul>

<h3>comment</h3>

<p>A CSS comment starts with <code>/*</code> and ends with <code>*/</code></p>

<p>Node-specific properties:</p>

<ul>
  <li><strong>value</strong>: The comment value without <code>/*</code> and <code>*/</code></li>
  <li><strong>unclosed</strong>: <code>true</code> if the comment was not closed properly. e.g. <code>/* comment without an end  </code>.</li>
</ul>

<h3>function</h3>

<p>A CSS function, e.g. <code>rgb(0,0,0)</code> or <code>url(foo.bar)</code>.</p>

<p>Function nodes have nodes nested within them: the function arguments.</p>

<p>Additional properties:</p>

<ul>
  <li><strong>value</strong>: The name of the function, e.g. <code>rgb</code> in <code>rgb(0,0,0)</code>.</li>
  <li><strong>before</strong>: Whitespace after the opening parenthesis and before the first argument,
e.g. `  ` in <code>rgb(  0,0,0)</code>.</li>
  <li><strong>after</strong>: Whitespace before the closing parenthesis and after the last argument,
e.g. `  ` in <code>rgb(0,0,0  )</code>.</li>
  <li><strong>nodes</strong>: More nodes representing the arguments to the function.</li>
  <li><strong>unclosed</strong>: <code>true</code> if the parentheses was not closed properly. e.g. <code>( unclosed-function  </code>.</li>
</ul>

<p>Media features surrounded by parentheses are considered functions with an
empty value. For example, <code>(min-width: 700px)</code> parses to these nodes:</p>

<p><code>js
[
  {
    type: 'function', value: '', before: '', after: '',
    nodes: [
      { type: 'word', value: 'min-width' },
      { type: 'div', value: ':', before: '', after: ' ' },
      { type: 'word', value: '700px' }
    ]
  }
]
</code></p>

<p><code>url()</code> functions can be parsed a little bit differently depending on
whether the first character in the argument is a quotation mark.</p>

<p><code>url( /gfx/img/bg.jpg )</code> parses to:</p>

<p><code>js
{ type: 'function', sourceIndex: 0, value: 'url', before: ' ', after: ' ', nodes: [
    { type: 'word', sourceIndex: 5, value: '/gfx/img/bg.jpg' }
] }
</code></p>

<p><code>url( "/gfx/img/bg.jpg" )</code>, on the other hand, parses to:</p>

<p><code>js
{ type: 'function', sourceIndex: 0, value: 'url', before: ' ', after: ' ', nodes: [
     type: 'string', sourceIndex: 5, quote: '"', value: '/gfx/img/bg.jpg' },
] }
</code></p>

<h2>API</h2>

<p><code>
var valueParser = require('postcss-value-parser');
</code></p>

<h3>valueParser.unit(quantity)</h3>

<p>Parses <code>quantity</code>, distinguishing the number from the unit. Returns an object like the following:</p>

<p><code>js
// Given 2rem
{
  number: '2',
  unit: 'rem'
}
</code></p>

<p>If the <code>quantity</code> argument cannot be parsed as a number, returns <code>false</code>.</p>

<p><em>This function does not parse complete values</em>: you cannot pass it <code>1px solid black</code> and expect <code>px</code> as
the unit. Instead, you should pass it single quantities only. Parse <code>1px solid black</code>, then pass it
the stringified <code>1px</code> node (a <code>word</code> node) to parse the number and unit.</p>

<h3>valueParser.stringify(nodes[, custom])</h3>

<p>Stringifies a node or array of nodes.</p>

<p>The <code>custom</code> function is called for each <code>node</code>; return a string to override the default behaviour.</p>

<h3>valueParser.walk(nodes, callback[, bubble])</h3>

<p>Walks each provided node, recursively walking all descendent nodes within functions.</p>

<p>Returning <code>false</code> in the <code>callback</code> will prevent traversal of descendent nodes (within functions).
You can use this feature to for shallow iteration, walking over only the <em>immediate</em> children.
<em>Note: This only applies if <code>bubble</code> is <code>false</code> (which is the default).</em></p>

<p>By default, the tree is walked from the outermost node inwards.
To reverse the direction, pass <code>true</code> for the <code>bubble</code> argument.</p>

<p>The <code>callback</code> is invoked with three arguments: <code>callback(node, index, nodes)</code>.</p>

<ul>
  <li><code>node</code>: The current node.</li>
  <li><code>index</code>: The index of the current node.</li>
  <li><code>nodes</code>: The complete nodes array passed to <code>walk()</code>.</li>
</ul>

<p>Returns the <code>valueParser</code> instance.</p>

<h3>var parsed = valueParser(value)</h3>

<p>Returns the parsed node tree.</p>

<h3>parsed.nodes</h3>

<p>The array of nodes.</p>

<h3>parsed.toString()</h3>

<p>Stringifies the node tree.</p>

<h3>parsed.walk(callback[, bubble])</h3>

<p>Walks each node inside <code>parsed.nodes</code>. See the documentation for <code>valueParser.walk()</code> above.</p>

<h1>License</h1>

<p>MIT © <a href="mailto:trysound@yandex.ru">Bogdan Chadkin</a></p>