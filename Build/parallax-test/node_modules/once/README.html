<h1>once</h1>

<p>Only call a function once.</p>

<h2>usage</h2>

<p>```javascript
var once = require(‘once’)</p>

<p>function load (file, cb) {
  cb = once(cb)
  loader.load(‘file’)
  loader.once(‘load’, cb)
  loader.once(‘error’, cb)
}
```</p>

<p>Or add to the Function.prototype in a responsible way:</p>

<p>```javascript
// only has to be done once
require(‘once’).proto()</p>

<p>function load (file, cb) {
  cb = cb.once()
  loader.load(‘file’)
  loader.once(‘load’, cb)
  loader.once(‘error’, cb)
}
```</p>

<p>Ironically, the prototype feature makes this module twice as
complicated as necessary.</p>

<p>To check whether you function has been called, use <code>fn.called</code>. Once the
function is called for the first time the return value of the original
function is saved in <code>fn.value</code> and subsequent calls will continue to
return this value.</p>

<p>```javascript
var once = require(‘once’)</p>

<p>function load (cb) {
  cb = once(cb)
  var stream = createStream()
  stream.once(‘data’, cb)
  stream.once(‘end’, function () {
    if (!cb.called) cb(new Error(‘not found’))
  })
}
```</p>

<h2><code>once.strict(func)</code></h2>

<p>Throw an error if the function is called twice.</p>

<p>Some functions are expected to be called only once. Using <code>once</code> for them would
potentially hide logical errors.</p>

<p>In the example below, the <code>greet</code> function has to call the callback only once:</p>

<p>```javascript
function greet (name, cb) {
  // return is missing from the if statement
  // when no name is passed, the callback is called twice
  if (!name) cb(‘Hello anonymous’)
  cb(‘Hello ‘ + name)
}</p>

<p>function log (msg) {
  console.log(msg)
}</p>

<p>// this will print ‘Hello anonymous’ but the logical error will be missed
greet(null, once(msg))</p>

<p>// once.strict will print ‘Hello anonymous’ and throw an error when the callback will be called the second time
greet(null, once.strict(msg))
```</p>