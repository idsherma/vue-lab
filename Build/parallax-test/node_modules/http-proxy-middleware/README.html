<h1>http-proxy-middleware</h1>

<p><a href="https://travis-ci.org/chimurai/http-proxy-middleware"><img src="https://img.shields.io/travis/chimurai/http-proxy-middleware/master.svg?style=flat-square" alt="Build Status" /></a>
<a href="https://coveralls.io/r/chimurai/http-proxy-middleware"><img src="https://img.shields.io/coveralls/chimurai/http-proxy-middleware.svg?style=flat-square" alt="Coveralls" /></a>
<a href="https://david-dm.org/chimurai/http-proxy-middleware#info=dependencies"><img src="https://img.shields.io/david/chimurai/http-proxy-middleware.svg?style=flat-square" alt="dependency Status" /></a>
<a href="https://snyk.io/test/npm/http-proxy-middleware"><img src="https://snyk.io/test/npm/http-proxy-middleware/badge.svg" alt="dependency Status" /></a></p>

<p>Node.js proxying made simple. Configure proxy middleware with ease for <a href="https://github.com/senchalabs/connect">connect</a>, <a href="https://github.com/strongloop/express">express</a>, <a href="https://github.com/BrowserSync/browser-sync">browser-sync</a> and <a href="#compatible-servers">many more</a>.</p>

<p>Powered by the popular Nodejitsu <a href="https://github.com/nodejitsu/node-http-proxy"><code>http-proxy</code></a>. <a href="https://github.com/nodejitsu/node-http-proxy"><img src="https://img.shields.io/github/stars/nodejitsu/node-http-proxy.svg?style=social&label=Star" alt="GitHub stars" /></a></p>

<h2>TL;DR</h2>

<p>Proxy <code>/api</code> requests to <code>http://www.example.org</code></p>

<p>```javascript
var express = require(‘express’);
var proxy = require(‘http-proxy-middleware’);</p>

<p>var app = express();</p>

<p>app.use(‘/api’, proxy({target: ‘http://www.example.org’, changeOrigin: true}));
app.listen(3000);</p>

<p>// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar
```</p>

<p><em>All</em> <code>http-proxy</code> <a href="https://github.com/nodejitsu/node-http-proxy#options">options</a> can be used, along with some extra <code>http-proxy-middleware</code> <a href="#options">options</a>.</p>

<p>:bulb: <strong>Tip:</strong> Set the option <code>changeOrigin</code> to <code>true</code> for <a href="http://en.wikipedia.org/wiki/Virtual_hosting#Name-based">name-based virtual hosted sites</a>.</p>

<h2>Table of Contents</h2>

<!-- MarkdownTOC autolink=true bracket=round depth=2 -->

<ul>
  <li><a href="#install">Install</a></li>
  <li><a href="#core-concept">Core concept</a></li>
  <li><a href="#example">Example</a></li>
  <li><a href="#context-matching">Context matching</a></li>
  <li><a href="#options">Options</a>
    <ul>
      <li><a href="#http-proxy-middleware-options">http-proxy-middleware options</a></li>
      <li><a href="#http-proxy-events">http-proxy events</a></li>
      <li><a href="#http-proxy-options">http-proxy options</a></li>
    </ul>
  </li>
  <li><a href="#shorthand">Shorthand</a>
    <ul>
      <li><a href="#appusepath-proxy">app.use(path, proxy)</a></li>
    </ul>
  </li>
  <li><a href="#websocket">WebSocket</a>
    <ul>
      <li><a href="#external-websocket-upgrade">External WebSocket upgrade</a></li>
    </ul>
  </li>
  <li><a href="#working-examples">Working examples</a></li>
  <li><a href="#recipes">Recipes</a></li>
  <li><a href="#compatible-servers">Compatible servers</a></li>
  <li><a href="#tests">Tests</a></li>
  <li><a href="#changelog">Changelog</a></li>
  <li><a href="#license">License</a></li>
</ul>

<!-- /MarkdownTOC -->

<h2>Install</h2>

<p><code>javascript
$ npm install --save-dev http-proxy-middleware
</code></p>

<h2>Core concept</h2>

<p>Proxy middleware configuration.</p>

<h4>proxy([context,] config)</h4>

<p>```javascript
var proxy = require(‘http-proxy-middleware’);</p>

<p>var apiProxy = proxy(‘/api’, {target: ‘http://www.example.org’});
//                   _<strong><em>/   _</em></strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong>_/
//                     |                    |
//                   context             options</p>

<p>// ‘apiProxy’ is now ready to be used as middleware in a server.
```
* <strong>context</strong>: Determine which requests should be proxied to the target host.
    (more on <a href="#context-matching">context matching</a>)
* <strong>options.target</strong>: target host to proxy to. <em>(protocol + host)</em></p>

<p>(full list of <a href="#options"><code>http-proxy-middleware</code> configuration options</a>)</p>

<h4>proxy(uri [, config])</h4>

<p>``` javascript
// shorthand syntax for the example above:
var apiProxy = proxy(‘http://www.example.org/api’);</p>

<p>```
More about the <a href="#shorthand">shorthand configuration</a>.</p>

<h2>Example</h2>

<p>An example with <code>express</code> server.</p>

<p>```javascript
// include dependencies
var express = require(‘express’);
var proxy = require(‘http-proxy-middleware’);</p>

<p>// proxy middleware options
var options = {
        target: ‘http://www.example.org’, // target host
        changeOrigin: true,               // needed for virtual hosted sites
        ws: true,                         // proxy websockets
        pathRewrite: {
            ‘^/api/old-path’ : ‘/api/new-path’,     // rewrite path
            ‘^/api/remove/path’ : ‘/path’           // remove base path
        },
        router: {
            // when request.headers.host == ‘dev.localhost:3000’,
            // override target ‘http://www.example.org’ to ‘http://localhost:8000’
            ‘dev.localhost:3000’ : ‘http://localhost:8000’
        }
    };</p>

<p>// create the proxy (without context)
var exampleProxy = proxy(options);</p>

<p>// mount <code>exampleProxy</code> in web server
var app = express();
    app.use(‘/api’, exampleProxy);
    app.listen(3000);
```</p>

<h2>Context matching</h2>

<p>Providing an alternative way to decide which requests should be proxied; In case you are not able to use the server’s <a href="http://expressjs.com/en/4x/api.html#app.use"><code>path</code> parameter</a> to mount the proxy or when you need more flexibility.</p>

<p>The <a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986 <code>path</code></a> is be used for context matching.</p>

<p><code>
         foo://example.com:8042/over/there?name=ferret#nose
         \_/   \______________/\_________/ \_________/ \__/
          |           |            |            |        |
       scheme     authority       path        query   fragment
</code></p>

<ul>
  <li><strong>path matching</strong>
    <ul>
      <li><code>proxy({...})</code> - matches any path, all requests will be proxied.</li>
      <li><code>proxy('/', {...})</code> - matches any path, all requests will be proxied.</li>
      <li><code>proxy('/api', {...})</code> - matches paths starting with <code>/api</code></li>
    </ul>
  </li>
  <li><strong>multiple path matching</strong>
    <ul>
      <li><code>proxy(['/api', '/ajax', '/someotherpath'], {...})</code> </li>
    </ul>
  </li>
  <li>
    <p><strong>wildcard path matching</strong></p>

    <p>For fine-grained control you can use wildcard matching. Glob pattern matching is done by <em>micromatch</em>. Visit <a href="https://www.npmjs.com/package/micromatch">micromatch</a> or <a href="https://www.npmjs.com/package/glob">glob</a> for more globbing examples.
  - <code>proxy('**', {...})</code> matches any path, all requests will be proxied.
  - <code>proxy('**/*.html', {...})</code> matches any path which ends with <code>.html</code>
  - <code>proxy('/*.html', {...})</code> matches paths directly under path-absolute
  - <code>proxy('/api/**/*.html', {...})</code> matches requests ending with <code>.html</code> in the path of <code>/api</code>
  - <code>proxy(['/api/**', '/ajax/**'], {...})</code> combine multiple patterns
  - <code>proxy(['/api/**', '!**/bad.json'], {...})</code> exclusion</p>
  </li>
  <li>
    <p><strong>custom matching</strong></p>

    <p>For full control you can provide a custom function to determine which requests should be proxied or not.
  ```javascript
  /**
   * @return {Boolean}
   */
  var filter = function (pathname, req) {
      return (pathname.match(‘^/api’) && req.method === ‘GET’);
  };</p>

    <p>var apiProxy = proxy(filter, {target: ‘http://www.example.org’})
  ```</p>
  </li>
</ul>

<h2>Options</h2>

<h3>http-proxy-middleware options</h3>

<ul>
  <li>
    <p><strong>option.pathRewrite</strong>: object/function, rewrite target’s url path. Object-keys will be used as <em>RegExp</em> to match paths.
 ```javascript
 // rewrite path
 pathRewrite: {‘^/old/api’ : ‘/new/api’}</p>

    <p>// remove path
 pathRewrite: {‘^/remove/api’ : ‘’}</p>

    <p>// add base path
 pathRewrite: {‘^/’ : ‘/basepath/’}</p>

    <p>// custom rewriting
 pathRewrite: function (path, req) { return path.replace(‘/api’, ‘/base/api’) }
 ```</p>
  </li>
  <li>
    <p><strong>option.router</strong>: object/function, re-target <code>option.target</code> for specific requests.
  ```javascript
  // Use <code>host</code> and/or <code>path</code> to match requests. First match will be used.
  // The order of the configuration matters.
  router: {
      ‘integration.localhost:3000’ : ‘http://localhost:8001’,  // host only
      ‘staging.localhost:3000’     : ‘http://localhost:8002’,  // host only
      ‘localhost:3000/api’         : ‘http://localhost:8003’,  // host + path
      ‘/rest’                      : ‘http://localhost:8004’   // path only
  }</p>

    <p>// Custom router function
  router: function(req) {
      return ‘http://localhost:8004’;
  }
  ```</p>
  </li>
  <li>
    <p><strong>option.logLevel</strong>: string, [‘debug’, ‘info’, ‘warn’, ‘error’, ‘silent’]. Default: <code>'info'</code></p>
  </li>
  <li>
    <p><strong>option.logProvider</strong>: function, modify or replace log provider. Default: <code>console</code>.
 <code>javascript
 // simple replace
 function logProvider(provider) {
     // replace the default console log provider.
     return require('winston');
 }
</code></p>

    <p>```javascript
 // verbose replacement
 function logProvider(provider) {
     var logger = new (require(‘winston’).Logger)();</p>

    <pre><code> var myCustomProvider = {
     log: logger.log,
     debug: logger.debug,
     info: logger.info,
     warn: logger.warn,
     error: logger.error
 }
 return myCustomProvider;  }  ```
</code></pre>
  </li>
  <li>(DEPRECATED) <strong>option.proxyHost</strong>: Use <code>option.changeOrigin = true</code> instead.</li>
  <li>(DEPRECATED) <strong>option.proxyTable</strong>: Use <code>option.router</code> instead.</li>
</ul>

<h3>http-proxy events</h3>

<p>Subscribe to <a href="https://github.com/nodejitsu/node-http-proxy#listening-for-proxy-events">http-proxy events</a>:</p>

<ul>
  <li>
    <p><strong>option.onError</strong>: function, subscribe to http-proxy’s <code>error</code> event for custom error handling.
 <code>javascript
 function onError(err, req, res) {
     res.writeHead(500, {
         'Content-Type': 'text/plain'
     });
     res.end('Something went wrong. And we are reporting a custom error message.');
 }
</code></p>
  </li>
  <li>
    <p><strong>option.onProxyRes</strong>: function, subscribe to http-proxy’s <code>proxyRes</code> event.
 <code>javascript
 function onProxyRes(proxyRes, req, res) {
     proxyRes.headers['x-added'] = 'foobar';     // add new header to response
     delete proxyRes.headers['x-removed'];       // remove header from response
 }
</code></p>
  </li>
  <li>
    <p><strong>option.onProxyReq</strong>: function, subscribe to http-proxy’s <code>proxyReq</code> event.
 <code>javascript
 function onProxyReq(proxyReq, req, res) {
     // add custom header to request
     proxyReq.setHeader('x-added', 'foobar');
     // or log the req
 }
</code></p>
  </li>
  <li>
    <p><strong>option.onProxyReqWs</strong>: function, subscribe to http-proxy’s <code>proxyReqWs</code> event.
 <code>javascript
 function onProxyReqWs(proxyReq, req, socket, options, head) {
     // add custom header
     proxyReq.setHeader('X-Special-Proxy-Header', 'foobar');
 }
</code></p>
  </li>
  <li>
    <p><strong>option.onOpen</strong>: function, subscribe to http-proxy’s <code>open</code> event.
 <code>javascript
 function onOpen(proxySocket) {
     // listen for messages coming FROM the target here
     proxySocket.on('data', hybiParseAndLogMessage);
 }
</code></p>
  </li>
  <li>
    <p><strong>option.onClose</strong>: function, subscribe to http-proxy’s <code>close</code> event.
 <code>javascript
 function onClose(res, socket, head) {
     // view disconnected websocket connections
     console.log('Client disconnected');
 }
</code></p>
  </li>
</ul>

<h3>http-proxy options</h3>

<p>The following options are provided by the underlying <a href="https://github.com/nodejitsu/node-http-proxy#options">http-proxy</a> library.</p>

<ul>
  <li><strong>option.target</strong>: url string to be parsed with the url module</li>
  <li><strong>option.forward</strong>: url string to be parsed with the url module</li>
  <li><strong>option.agent</strong>: object to be passed to http(s).request (see Node’s <a href="http://nodejs.org/api/https.html#https_class_https_agent">https agent</a> and <a href="http://nodejs.org/api/http.html#http_class_http_agent">http agent</a> objects)</li>
  <li><strong>option.ssl</strong>: object to be passed to https.createServer()</li>
  <li><strong>option.ws</strong>: true/false: if you want to proxy websockets</li>
  <li><strong>option.xfwd</strong>: true/false, adds x-forward headers</li>
  <li><strong>option.secure</strong>: true/false, if you want to verify the SSL Certs</li>
  <li><strong>option.toProxy</strong>: true/false, passes the absolute URL as the <code>path</code> (useful for proxying to proxies)</li>
  <li><strong>option.prependPath</strong>: true/false, Default: true - specify whether you want to prepend the target’s path to the proxy path</li>
  <li><strong>option.ignorePath</strong>: true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request (note: you will have to append / manually if required).</li>
  <li><strong>option.localAddress</strong> : Local interface string to bind for outgoing connections</li>
  <li><strong>option.changeOrigin</strong>: true/false, Default: false - changes the origin of the host header to the target URL</li>
  <li><strong>option.auth</strong> : Basic authentication i.e. ‘user:password’ to compute an Authorization header.</li>
  <li><strong>option.hostRewrite</strong>: rewrites the location hostname on (301/302/307/308) redirects.</li>
  <li><strong>option.autoRewrite</strong>: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false.</li>
  <li><strong>option.protocolRewrite</strong>: rewrites the location protocol on (301/302/307/308) redirects to ‘http’ or ‘https’. Default: null.</li>
  <li><strong>option.cookieDomainRewrite</strong>: rewrites domain of <code>set-cookie</code> headers. Possible values:
    <ul>
      <li><code>false</code> (default): disable cookie rewriting</li>
      <li>String: new domain, for example <code>cookieDomainRewrite: "new.domain"</code>. To remove the domain, use <code>cookieDomainRewrite: ""</code>.</li>
      <li>Object: mapping of domains to new domains, use <code>"*"</code> to match all domains.<br />
For example keep one domain unchanged, rewrite one domain and remove other domains:
<code>
cookieDomainRewrite: {
  "unchanged.domain": "unchanged.domain",
  "old.domain": "new.domain",
  "*": ""
}
</code></li>
    </ul>
  </li>
  <li><strong>option.headers</strong>: object, adds <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields">request headers</a>. (Example: <code>{host:'www.example.org'}</code>)</li>
  <li><strong>option.proxyTimeout</strong>: timeout (in millis) when proxy receives no response from target</li>
</ul>

<h2>Shorthand</h2>

<p>Use the shorthand syntax when verbose configuration is not needed. The <code>context</code> and <code>option.target</code> will be automatically configured when shorthand is used. Options can still be used if needed.</p>

<p>```javascript
proxy(‘http://www.example.org:8000/api’);
// proxy(‘/api’, {target: ‘http://www.example.org:8000’});</p>

<p>proxy(‘http://www.example.org:8000/api/books/*/<strong>.json’);
// proxy(‘/api/books/*/</strong>.json’, {target: ‘http://www.example.org:8000’});</p>

<p>proxy(‘http://www.example.org:8000/api’, {changeOrigin:true});
// proxy(‘/api’, {target: ‘http://www.example.org:8000’, changeOrigin: true});
```</p>

<h3>app.use(path, proxy)</h3>

<p>If you want to use the server’s <code>app.use</code> <code>path</code> parameter to match requests; 
Create and mount the proxy without the http-proxy-middleware <code>context</code> parameter:
<code>javascript
app.use('/api', proxy({target:'http://www.example.org', changeOrigin:true}));
</code></p>

<p><code>app.use</code> documentation:
* express: http://expressjs.com/en/4x/api.html#app.use
* connect: https://github.com/senchalabs/connect#mount-middleware</p>

<h2>WebSocket</h2>

<p>```javascript
// verbose api
proxy(‘/’, {target:’http://echo.websocket.org’, ws:true});</p>

<p>// shorthand
proxy(‘http://echo.websocket.org’, {ws:true});</p>

<p>// shorter shorthand
proxy(‘ws://echo.websocket.org’);
```</p>

<h3>External WebSocket upgrade</h3>

<p>In the previous WebSocket examples, http-proxy-middleware relies on a initial http request in order to listen to the http <code>upgrade</code> event. If you need to proxy WebSockets without the initial http request, you can subscribe to the server’s http <code>upgrade</code> event manually.
```javascript
var wsProxy = proxy(‘ws://echo.websocket.org’, {changeOrigin:true});</p>

<p>var app = express();
    app.use(wsProxy);</p>

<p>var server = app.listen(3000);
    server.on(‘upgrade’, wsProxy.upgrade);  // <– subscribe to http ‘upgrade’
```</p>

<h2>Working examples</h2>

<p>View and play around with <a href="https://github.com/chimurai/http-proxy-middleware/tree/master/examples">working examples</a>.</p>

<ul>
  <li>Browser-Sync (<a href="https://github.com/chimurai/http-proxy-middleware/tree/master/examples/browser-sync/index.js">example source</a>)</li>
  <li>express (<a href="https://github.com/chimurai/http-proxy-middleware/tree/master/examples/express/index.js">example source</a>)</li>
  <li>connect (<a href="https://github.com/chimurai/http-proxy-middleware/tree/master/examples/connect/index.js">example source</a>)</li>
  <li>WebSocket (<a href="https://github.com/chimurai/http-proxy-middleware/tree/master/examples/websocket/index.js">example source</a>)</li>
</ul>

<h2>Recipes</h2>

<p>View the <a href="https://github.com/chimurai/http-proxy-middleware/tree/master/recipes">recipes</a> for common use cases.</p>

<h2>Compatible servers</h2>

<p><code>http-proxy-middleware</code> is compatible with the following servers:
* <a href="https://www.npmjs.com/package/connect">connect</a>
* <a href="https://www.npmjs.com/package/express">express</a>
* <a href="https://www.npmjs.com/package/browser-sync">browser-sync</a>
* <a href="https://www.npmjs.com/package/lite-server">lite-server</a>
* <a href="https://www.npmjs.com/package/grunt-contrib-connect">grunt-contrib-connect</a>
* <a href="https://www.npmjs.com/package/grunt-browser-sync">grunt-browser-sync</a>
* <a href="https://www.npmjs.com/package/gulp-connect">gulp-connect</a>
* <a href="https://www.npmjs.com/package/gulp-webserver">gulp-webserver</a></p>

<p>Sample implementations can be found in the <a href="https://github.com/chimurai/http-proxy-middleware/tree/master/recipes/servers.md">server recipes</a>.</p>

<h2>Tests</h2>

<p>Run the test suite:</p>

<p><code>bash
# install dependencies
$ npm install
</code></p>

<p>unit testing</p>

<p><code>bash
# unit tests
$ npm test
</code></p>

<p>coverage</p>

<p><code>bash
# code coverage
$ npm run cover
</code></p>

<h2>Changelog</h2>

<ul>
  <li><a href="https://github.com/chimurai/http-proxy-middleware/blob/master/CHANGELOG.md">View changelog</a></li>
</ul>

<h2>License</h2>

<p>The MIT License (MIT)</p>

<p>Copyright (c) 2015-2017 Steven Chim</p>