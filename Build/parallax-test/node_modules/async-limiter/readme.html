<h1>Async-Limiter</h1>

<p>A module for limiting concurrent asynchronous actions in flight. Forked from <a href="https://github.com/jessetane/queue">queue</a>.</p>

<p><a href="http://www.npmjs.org/async-limiter"><img src="http://img.shields.io/npm/v/async-limiter.svg?style=flat-square" alt="npm" /></a>
<a href="https://travis-ci.org/STRML/async-limiter"><img src="https://img.shields.io/travis/STRML/async-limiter.svg?style=flat-square&branch=master" alt="tests" /></a>
<a href="https://coveralls.io/r/STRML/async-limiter"><img src="https://img.shields.io/coveralls/STRML/async-limiter.svg?style=flat-square&branch=master" alt="coverage" /></a></p>

<p>This module exports a class <code>Limiter</code> that implements some of the <code>Array</code> API.
Pass async functions (ones that accept a callback or return a promise) to an instance’s additive array methods.</p>

<h2>Motivation</h2>

<p>Certain functions, like <code>zlib</code>, have <a href="https://github.com/nodejs/node/issues/8871#issuecomment-250915913">undesirable behavior</a> when
run at infinite concurrency.</p>

<p>In this case, it is actually faster, and takes far less memory, to limit concurrency.</p>

<p>This module should do the absolute minimum work necessary to queue up functions. PRs are welcome that would
make this module faster or lighter, but new functionality is not desired.</p>

<p>Style should confirm to nodejs/node style.</p>

<h2>Example</h2>

<p>``` javascript
var Limiter = require(‘async-limiter’)</p>

<p>var t = new Limiter({concurrency: 2});
var results = []</p>

<p>// add jobs using the familiar Array API
t.push(function (cb) {
  results.push(‘two’)
  cb()
})</p>

<p>t.push(
  function (cb) {
    results.push(‘four’)
    cb()
  },
  function (cb) {
    results.push(‘five’)
    cb()
  }
)</p>

<p>t.unshift(function (cb) {
  results.push(‘one’)
  cb()
})</p>

<p>t.splice(2, 0, function (cb) {
  results.push(‘three’)
  cb()
})</p>

<p>// Jobs run automatically. If you want a callback when all are done,
// call ‘onDone()’.
t.onDone(function () {
  console.log(‘all done:’, results)
})
```</p>

<h2>Zlib Example</h2>

<p>```js
const zlib = require(‘zlib’);
const Limiter = require(‘async-limiter’);</p>

<p>const message = {some: “data”};
const payload = new Buffer(JSON.stringify(message));</p>

<p>// Try with different concurrency values to see how this actually
// slows significantly with higher concurrency!
//
// 5:        1398.607ms
// 10:       1375.668ms
// Infinity: 4423.300ms
//
const t = new Limiter({concurrency: 5});
function deflate(payload, cb) {
  t.push(function(done) {
    zlib.deflate(payload, function(err, buffer) {
      done();
      cb(err, buffer);
    });
  });
}</p>

<p>console.time(‘deflate’);
for(let i = 0; i < 30000; ++i) {
  deflate(payload, function (err, buffer) {});
}
q.onDone(function() {
  console.timeEnd(‘deflate’);
});
```</p>

<h2>Install</h2>

<p><code>npm install async-limiter</code></p>

<h2>Test</h2>

<p><code>npm test</code></p>

<h2>API</h2>

<h3><code>var t = new Limiter([opts])</code></h3>
<p>Constructor. <code>opts</code> may contain inital values for:
* <code>q.concurrency</code></p>

<h2>Instance methods</h2>

<h3><code>q.onDone(fn)</code></h3>
<p><code>fn</code> will be called once and only once, when the queue is empty.</p>

<h2>Instance methods mixed in from <code>Array</code></h2>
<p>Mozilla has docs on how these methods work <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">here</a>.
### <code>q.push(element1, ..., elementN)</code>
### <code>q.unshift(element1, ..., elementN)</code>
### <code>q.splice(index , howMany[, element1[, ...[, elementN]]])</code></p>

<h2>Properties</h2>
<p>### <code>q.concurrency</code>
Max number of jobs the queue should process concurrently, defaults to <code>Infinity</code>.</p>

<h3><code>q.length</code></h3>
<p>Jobs pending + jobs to process (readonly).</p>