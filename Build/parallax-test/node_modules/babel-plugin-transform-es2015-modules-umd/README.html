<h1>babel-plugin-transform-es2015-modules-umd</h1>

<blockquote>
  <p>This plugin transforms ES2015 modules to <a href="https://github.com/umdjs/umd">Universal Module Definition (UMD)</a>.</p>
</blockquote>

<h2>Example</h2>

<p><strong>In</strong></p>

<p><code>javascript
export default 42;
</code></p>

<p><strong>Out</strong></p>

<p>```javascript
(function (global, factory) {
  if (typeof define === “function” && define.amd) {
    define([“exports”], factory);
  } else if (typeof exports !== “undefined”) {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.actual = mod.exports;
  }
})(this, function (exports) {
  “use strict”;</p>

<p>Object.defineProperty(exports, “__esModule”, {
    value: true
  });</p>

<p>exports.default = 42;
});
```</p>

<h2>Installation</h2>

<p><code>sh
npm install --save-dev babel-plugin-transform-es2015-modules-umd
</code></p>

<h2>Usage</h2>

<h3>Via <code>.babelrc</code> (Recommended)</h3>

<p><strong>.babelrc</strong></p>

<p><code>json
{
  "plugins": ["transform-es2015-modules-umd"]
}
</code></p>

<p>You can also override the names of particular libraries when this module is
running in the browser.  For example the <code>es6-promise</code> library exposes itself
as <code>global.Promise</code> rather than <code>global.es6Promise</code>. This can be accommodated by:</p>

<p><code>json
{
  "plugins": [
    ["transform-es2015-modules-umd", {
      "globals": {
        "es6-promise": "Promise"
      }
    }]
  ]
}
</code></p>

<h4>Default semantics</h4>

<p>There are a few things to note about the default semantics.</p>

<p><em>First</em>, this transform uses the
<a href="https://en.wikipedia.org/wiki/Basename">basename</a> of each import to generate
the global names in the UMD output. This means that if you’re importing
multiple modules with the same basename, like:</p>

<p><code>js
import fooBar1 from "foo-bar";
import fooBar2 from "./mylib/foo-bar";
</code></p>

<p>it will transpile into two references to the same browser global:</p>

<p><code>js
factory(global.fooBar, global.fooBar);
</code></p>

<p>If you set the plugin options to:</p>

<p><code>json
{
  "globals": {
    "foo-bar": "fooBAR",
    "./mylib/foo-bar": "mylib.fooBar"
  }
}
</code></p>

<p>it will still transpile both to one browser global:</p>

<p><code>js
factory(global.fooBAR, global.fooBAR);
</code></p>

<p>because again the transform is only using the basename of the import.</p>

<p><em>Second</em>, the specified override will still be passed to the <code>toIdentifier</code>
function in <a href="https://github.com/babel/babel/blob/master/packages/babel-types/src/converters.js">babel-types/src/converters</a>.
This means that if you specify an override as a member expression like:</p>

<p><code>json
{
  "globals": {
    "fizzbuzz": "fizz.buzz"
  }
}
</code></p>

<p>this will <em>not</em> transpile to <code>factory(global.fizz.buzz)</code>. Instead, it will
transpile to <code>factory(global.fizzBuzz)</code> based on the logic in <code>toIdentifier</code>.</p>

<p><em>Third</em>, you cannot override the exported global name.</p>

<h4>More flexible semantics with <code>exactGlobals: true</code></h4>

<p>All of these behaviors can limit the flexibility of the <code>globals</code> map. To
remove these limitations, you can set the <code>exactGlobals</code> option to <code>true</code>.
Doing this instructs the plugin to:</p>

<ol>
  <li>always use the full import string instead of the basename when generating
the global names</li>
  <li>skip passing <code>globals</code> overrides to the <code>toIdentifier</code> function. Instead,
they are used exactly as written, so you will get errors if you do not use
valid identifiers or valid uncomputed (dot) member expressions.</li>
  <li>allow the exported global name to be overridden via the <code>globals</code> map. Any
override must again be a valid identifier or valid member expression.</li>
</ol>

<p>Thus, if you set <code>exactGlobals</code> to <code>true</code> and do not pass any overrides, the
first example of:</p>

<p><code>js
import fooBar1 from "foo-bar";
import fooBar2 from "./mylib/foo-bar";
</code></p>

<p>will transpile to:</p>

<p><code>js
factory(global.fooBar, global.mylibFooBar);
</code></p>

<p>And if you set the plugin options to:</p>

<p><code>json
{
  "globals": {
    "foo-bar": "fooBAR",
    "./mylib/foo-bar": "mylib.fooBar"
  },
  "exactGlobals": true
}
</code></p>

<p>then it’ll transpile to:</p>

<p><code>js
factory(global.fooBAR, global.mylib.fooBar)
</code></p>

<p>Finally, with the plugin options set to:</p>

<p><code>json
{
  "plugins": [
    "external-helpers",
    ["transform-es2015-modules-umd", {
      "globals": {
        "my/custom/module/name": "My.Custom.Module.Name"
      },
      "exactGlobals": true
    }]
  ],
  "moduleId": "my/custom/module/name"
}
</code></p>

<p>it will transpile to:</p>

<p><code>js
factory(mod.exports);
global.My = global.My || {};
global.My.Custom = global.My.Custom || {};
global.My.Custom.Module = global.My.Custom.Module || {};
global.My.Custom.Module.Name = mod.exports;
</code></p>

<h3>Via CLI</h3>

<p><code>sh
babel --plugins transform-es2015-modules-umd script.js
</code></p>

<h3>Via Node API</h3>

<p><code>javascript
require("babel-core").transform("code", {
  plugins: ["transform-es2015-modules-umd"]
});
</code></p>