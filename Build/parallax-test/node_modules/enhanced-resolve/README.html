<h1>enhanced-resolve</h1>

<p>Offers an async require.resolve function. It’s highly configurable.</p>

<h2>Features</h2>

<ul>
  <li>plugin system</li>
  <li>provide a custom filesystem</li>
  <li>sync and async node.js filesystems included</li>
</ul>

<h2>Getting Started</h2>
<p>### Install
<code>sh
# npm
npm install enhanced-resolve
# or Yarn
yarn add enhanced-resolve
</code></p>

<h3>Creating a Resolver</h3>
<p>The easiest way to create a resolver is to use the <code>createResolver</code> function on <code>ResolveFactory</code>, along with one of the supplied File System implementations.
```js
const {
  NodeJsInputFileSystem,
  CachedInputFileSystem,
  ResolverFactory
} = require(‘enhanced-resolve’);</p>

<p>// create a resolver
const myResolver = ResolverFactory.createResolver({
  // Typical usage will consume the <code>NodeJsInputFileSystem</code> + <code>CachedInputFileSystem</code>, which wraps the Node.js <code>fs</code> wrapper to add resilience + caching.
  fileSystem: new CachedInputFileSystem(new NodeJsInputFileSystem(), 4000),
  extensions: [‘.js’, ‘.json’]
  /* any other resolver options here. Options/defaults can be seen below */
});</p>

<p>// resolve a file with the new resolver
const context = {};
const lookupStartPath = ‘/Users/webpack/some/root/dir’;
const request = ‘./path/to-look-up.js’;
myResolver.resolve({}, lookupStartPath, request, (err/<em>Error</em>/, filepath/<em>string</em>/) => {
  // Do something with the path
});
```</p>

<p>For more examples creating different types resolvers (sync/async, context, etc) see <code>lib/node.js</code>.
#### Resolver Options
| Field                    | Default                     | Description                                                                        |
| ———————— | ————————— | ———————————————————————————- |
| modules                  | [“node_modules”]            | A list of directories to resolve modules from, can be absolute path or folder name |
| descriptionFiles         | [“package.json”]            | A list of description files to read from |
| plugins                  | []                          | A list of additional resolve plugins which should be applied |
| mainFields               | [“main”]                    | A list of main fields in description files |
| aliasFields              | []                          | A list of alias fields in description files |
| mainFiles                | [“index”]                   | A list of main files in directories |
| extensions               | [“.js”, “.json”, “.node”]   | A list of extensions which should be tried for files |
| enforceExtension         | false                       | Enforce that a extension from extensions must be used |
| moduleExtensions         | []                          | A list of module extensions which should be tried for modules |
| enforceModuleExtension   | false                       | Enforce that a extension from moduleExtensions must be used |
| alias                    | []                          | A list of module alias configurations or an object which maps key to value |
| resolveToContext         | false                       | Resolve to a context instead of a file |
| unsafeCache              | false                       | Use this cache object to unsafely cache the successful requests |
| cacheWithContext         | true                        | If unsafe cache is enabled, includes <code>request.context</code> in the cache key  |
| cachePredicate           | function() { return true }; | A function which decides whether a request should be cached or not. An object is passed to the function with <code>path</code> and <code>request</code> properties. |
| fileSystem               |                             | The file system which should be used |
| resolver                 | undefined                   | A prepared Resolver to which the plugins are attached |</p>

<h2>Plugins</h2>
<p>Similar to <code>webpack</code>, the core of <code>enhanced-resolve</code> functionality is implemented as individual plugins that are executed using <a href="https://github.com/webpack/tapable"><code>Tapable</code></a>. These plugins can extend the functionality of the library, adding other ways for files/contexts to be resolved.</p>

<p>A plugin should be a <code>class</code> (or its ES5 equivalent) with an <code>apply</code> method. The <code>apply</code> method will receive a <code>resolver</code> instance, that can be used to hook in to the event system.</p>

<h3>Plugin Boilerplate</h3>
<p>```js
class MyResolverPlugin {
  constructor(source, target) {
    this.source = source;
    this.target = target;
  }</p>

<p>apply(resolver) {
    resolver.plugin(this.source, (request, callback) => {
      // Any logic you need to create a new <code>request</code> can go here
      resolver.doResolve(this.target, request, null, callback);
    });
  }
}
```</p>

<p>Plugins are executed in a pipeline, and register which event they should be executed before/after. In the example above, <code>source</code> is the name of the event that starts the pipeline, and <code>target</code> is what event this plugin should fire, which is what continues the execution of the pipeline. For an example of how these different plugin events create a chain, see <code>lib/ResolverFactory.js</code>, in the <code>//// pipeline ////</code> section.</p>

<h2>Tests</h2>

<p><code>javascript
npm test
</code></p>

<p><a href="http://travis-ci.org/webpack/enhanced-resolve"><img src="https://secure.travis-ci.org/webpack/enhanced-resolve.png?branch=master" alt="Build Status" /></a></p>

<h2>Passing options from webpack</h2>
<p>If you are using <code>webpack</code>, and you want to pass custom options to <code>enhanced-resolve</code>, the options are passed from the <code>resolve</code> key of your webpack configuration e.g.:</p>

<p><code>
resolve: {
  extensions: ['', '.js', '.jsx'],
  modules: ['src', 'node_modules'],
  plugins: [new DirectoryNamedWebpackPlugin()]
  ...
},
</code></p>

<h2>License</h2>

<p>Copyright (c) 2012-2016 Tobias Koppers</p>

<p>MIT (http://www.opensource.org/licenses/mit-license.php)</p>