<h1>babel-plugin-transform-vue-jsx <a href="https://circleci.com/gh/vuejs/babel-plugin-transform-vue-jsx"><img src="https://img.shields.io/circleci/project/vuejs/babel-plugin-transform-vue-jsx.svg?maxAge=2592000" alt="CircleCI" /></a></h1>

<blockquote>
  <p>Babel plugin for Vue 2.0 JSX</p>
</blockquote>

<h3>Requirements</h3>

<ul>
  <li>
    <p>Assumes you are using Babel with a module bundler e.g. Webpack, because the spread merge helper is imported as a module to avoid duplication.</p>
  </li>
  <li>
    <p>This is mutually exclusive with <code>babel-plugin-transform-react-jsx</code>.</p>
  </li>
</ul>

<h3>Usage</h3>

<p><code>bash
npm install\
  babel-plugin-syntax-jsx\
  babel-plugin-transform-vue-jsx\
  babel-helper-vue-jsx-merge-props\
  babel-preset-es2015\
  --save-dev
</code></p>

<p>In your <code>.babelrc</code>:</p>

<p><code>json
{
  "presets": ["es2015"],
  "plugins": ["transform-vue-jsx"]
}
</code></p>

<p>The plugin transpiles the following JSX:</p>

<p><code>jsx
<div id="foo">{this.text}</div>
</code></p>

<p>To the following JavaScript:</p>

<p><code>js
h('div', {
  attrs: {
    id: 'foo'
  }
}, [this.text])
</code></p>

<p>Note the <code>h</code> function, which is a shorthand for a Vue instance’s <code>$createElement</code> method, must be in the scope where the JSX is. Since this method is passed to component render functions as the first argument, in most cases you’d do this:</p>

<p><code>js
Vue.component('jsx-example', {
  render (h) { // <-- h must be in scope
    return <div id="foo">bar</div>
  }
})
</code></p>

<h3><code>h</code> auto-injection</h3>

<p>Starting with version 3.4.0 we automatically inject <code>const h = this.$createElement</code> in any method and getter (not functions or arrow functions) declared in ES2015 syntax that has JSX so you can drop the <code>(h)</code> parameter.</p>

<p>``` js</p>

<p>Vue.component(‘jsx-example’, {
  render () { // h will be injected
    return <div id="foo">bar</div>
  },
  myMethod: function () { // h will not be injected
    return <div id="foo">bar</div>
  },
  someOtherMethod: () => { // h will not be injected
    return <div id="foo">bar</div>
  }
})</p>

<p>@Component
class App extends Vue {
  get computed () { // h will be injected
    return <div id="foo">bar</div>
  }
}
```</p>

<h3>Difference from React JSX</h3>

<p>First, Vue 2.0’s vnode format is different from React’s. The second argument to the <code>createElement</code> call is a “data object” that accepts nested objects. Each nested object will be then processed by corresponding modules:</p>

<p><code>js
render (h) {
  return h('div', {
    // Component props
    props: {
      msg: 'hi'
    },
    // normal HTML attributes
    attrs: {
      id: 'foo'
    },
    // DOM props
    domProps: {
      innerHTML: 'bar'
    },
    // Event handlers are nested under "on", though
    // modifiers such as in v-on:keyup.enter are not
    // supported. You'll have to manually check the
    // keyCode in the handler instead.
    on: {
      click: this.clickHandler
    },
    // For components only. Allows you to listen to
    // native events, rather than events emitted from
    // the component using vm.$emit.
    nativeOn: {
      click: this.nativeClickHandler
    },
    // class is a special module, same API as `v-bind:class`
    class: {
      foo: true,
      bar: false
    },
    // style is also same as `v-bind:style`
    style: {
      color: 'red',
      fontSize: '14px'
    },
    // other special top-level properties
    key: 'key',
    ref: 'ref',
    // assign the `ref` is used on elements/components with v-for
    refInFor: true,
    slot: 'slot'
  })
}
</code></p>

<p>The equivalent of the above in Vue 2.0 JSX is:</p>

<p><code>jsx
render (h) {
  return (
    <div
      // normal attributes or component props.
      id="foo"
      // DOM properties are prefixed with `domProps`
      domPropsInnerHTML="bar"
      // event listeners are prefixed with `on` or `nativeOn`
      onClick={this.clickHandler}
      nativeOnClick={this.nativeClickHandler}
      // other special top-level properties
      class={{ foo: true, bar: false }}
      style={{ color: 'red', fontSize: '14px' }}
      key="key"
      ref="ref"
      // assign the `ref` is used on elements/components with v-for
      refInFor
      slot="slot">
    </div>
  )
}
</code></p>

<h3>Component Tip</h3>

<p>If a custom element starts with lowercase, it will be treated as a string id and used to lookup a registered component. If it starts with uppercase, it will be treated as an identifier, which allows you to do:</p>

<p>``` js
import Todo from ‘./Todo.js’</p>

<p>export default {
  render (h) {
    return <todo></todo> // no need to register Todo via components option
  }
}
```</p>

<h3>JSX Spread</h3>

<p>JSX spread is supported, and this plugin will intelligently merge nested data properties. For example:</p>

<p><code>jsx
const data = {
  class: ['b', 'c']
}
const vnode = <div class="a" {...data}/>
</code></p>

<p>The merged data will be:</p>

<p><code>js
{ class: ['a', 'b', 'c'] }
</code></p>

<h3>Vue directives</h3>

<p>Note that almost all built-in Vue directives are not supported when using JSX, the sole exception being <code>v-show</code>, which can be used with the <code>v-show={value}</code> syntax. In most cases there are obvious programmatic equivalents, for example <code>v-if</code> is just a ternary expression, and <code>v-for</code> is just an <code>array.map()</code> expression, etc.</p>

<p>For custom directives, you can use the <code>v-name={value}</code> syntax. However, note that directive arguments and modifiers are not supported using this syntax. There are two workarounds:</p>

<ol>
  <li>
    <p>Pass everything as an object via <code>value</code>, e.g. <code>v-name={{ value, modifier: true }}</code></p>
  </li>
  <li>
    <p>Use the raw vnode directive data format:</p>
  </li>
</ol>

<p>``` js
const directives = [
  { name: ‘my-dir’, value: 123, modifiers: { abc: true } }
]</p>

<p>return <div {…{ directives }}/>
```</p>