<h1>watchpack</h1>

<p>Wrapper library for directory and file watching.</p>

<p><a href="https://travis-ci.org/webpack/watchpack"><img src="https://travis-ci.org/webpack/watchpack.svg?branch=master" alt="Build Status" /></a> <a href="https://ci.appveyor.com/project/sokra/watchpack/branch/master"><img src="https://ci.appveyor.com/api/projects/status/e5u2qvmugtv0r647/branch/master?svg=true" alt="Build status" /></a> <a href="https://coveralls.io/r/webpack/watchpack/"><img src="https://img.shields.io/coveralls/webpack/watchpack.svg" alt="Test coverage" /></a></p>

<h2>Concept</h2>

<p>watchpack high level API don’t map directly to watchers. Instead a three level architecture ensures that for each directory only a single watcher exists.</p>

<ul>
  <li>The high level API requests <code>DirectoryWatchers</code> from a <code>WatcherManager</code>, which ensures that only a single <code>DirectoryWatcher</code> per directory is created.</li>
  <li>A user-faced <code>Watcher</code> can be obtained from a <code>DirectoryWatcher</code> and provides a filtered view on the <code>DirectoryWatcher</code>.</li>
  <li>Reference-counting is used on the <code>DirectoryWatcher</code> and <code>Watcher</code> to decide when to close them.</li>
  <li>The real watchers (currently chokidar) are created by the <code>DirectoryWatcher</code>.</li>
  <li>Files are never watched directly. This should keep the watcher count low.</li>
  <li>Watching can be started in the past. This way watching can start after file reading.</li>
  <li>Symlinks are not followed, instead the symlink is watched.</li>
</ul>

<h2>API</h2>

<p>``` javascript
var Watchpack = require(“watchpack”);</p>

<p>var wp = new Watchpack({
	// options:
	aggregateTimeout: 1000
	// fire “aggregated” event when after a change for 1000ms no additonal change occured
	// aggregated defaults to undefined, which doesn’t fire an “aggregated” event</p>

<pre><code>poll: true
// poll: true - use polling with the default interval
// poll: 10000 - use polling with an interval of 10s
// poll defaults to undefined, which prefer native watching methods
// Note: enable polling when watching on a network path

ignored: /node_modules/,
// anymatch-compatible definition of files/paths to be ignored
// see https://github.com/paulmillr/chokidar#path-filtering });
</code></pre>

<p>// Watchpack.prototype.watch(string[] files, string[] directories, [number startTime])
wp.watch(listOfFiles, listOfDirectories, Date.now() - 10000);
// starts watching these files and directories
// calling this again will override the files and directories</p>

<p>wp.on(“change”, function(filePath, mtime) {
	// filePath: the changed file
	// mtime: last modified time for the changed file
});</p>

<p>wp.on(“aggregated”, function(changes) {
	// changes: an array of all changed files
});</p>

<p>// Watchpack.prototype.pause()
wp.pause();
// stops emitting events, but keeps watchers open
// next “watch” call can reuse the watchers</p>

<p>// Watchpack.prototype.close()
wp.close();
// stops emitting events and closes all watchers</p>

<p>// Watchpack.prototype.getTimes()
var fileTimes = wp.getTimes();
// returns an object with all know change times for files
// this include timestamps from files not directly watched
// key: absolute path, value: timestamp as number
```</p>